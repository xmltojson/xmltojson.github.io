<!DOCTYPE html>
<!-- MIT License
Copyright (c) 2025 Valentyn Kolesnikov <0009-0003-9608-3364@orcid.org>
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Mahjong Solitaire">
    <link rel="icon" type="image/x-icon" href="Mahjong.ico"/>
    <title>Mahjong Solitaire</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            overflow-x: hidden;
        }

        .game-container {
            width: 100%;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: transparent;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        .game-header {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            width: 100%;
        }

        h1 {
            color: #764ba2;
            margin-bottom: 10px;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            white-space: nowrap;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.pause-btn {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        }

        button.pause-btn.paused {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 16px;
            color: #333;
            flex-wrap: wrap;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .stat-label {
            font-weight: bold;
        }

        .game-board-container {
            background: transparent;
            border-radius: 15px;
            padding: 20px;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            position: relative;
        }

        .board-wrapper {
            position: relative;
            display: inline-block;
            line-height: 0;
        }

        #gameBoard {
            position: relative;
            transform-origin: top left;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            overflow: visible;
        }

        .pause-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1500;
        }

        .pause-overlay.active {
            display: flex;
        }

        .pause-message {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.5);
            max-width: 400px;
            width: 90%;
        }

        .pause-message h2 {
            color: white;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .pause-message p {
            margin-bottom: 30px;
            color: white;
            font-size: 1.2em;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
        }

        .pause-message button {
            background: white;
            color: #764ba2;
            padding: 12px 30px;
            font-size: 18px;
            font-weight: bold;
        }

        .pause-message button:hover {
            background: #f0f0f0;
        }

        .tile {
            position: absolute;
            width: 50px;
            height: 65px;
            background: linear-gradient(145deg, #ffffff, #e6e6e6);
            border: 2px solid #999;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
            box-shadow: 
                2px 2px 5px rgba(0, 0, 0, 0.3),
                inset 1px 1px 2px rgba(255, 255, 255, 0.5);
            user-select: none;
            transform-style: preserve-3d;
        }

        .tile:hover:not(.blocked):not(.matched) {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 
                4px 4px 10px rgba(0, 0, 0, 0.4),
                inset 1px 1px 2px rgba(255, 255, 255, 0.5);
            background: linear-gradient(145deg, #f5f5f5, #ddd);
            z-index: 999 !important;
        }

        .tile.selected {
            background: linear-gradient(145deg, #ffd700, #ffed4e);
            border-color: #ffa500;
            transform: translateY(-2px) scale(1.05);
            box-shadow: 
                0 0 15px rgba(255, 215, 0, 0.6),
                4px 4px 10px rgba(0, 0, 0, 0.4);
            z-index: 998 !important;
        }

        .tile.blocked {
            opacity: 0.7;
            cursor: not-allowed;
            filter: brightness(0.8);
        }

        .tile.matched {
            animation: matchAnimation 0.5s forwards;
            pointer-events: none;
        }

        @keyframes matchAnimation {
            0% {
                transform: scale(1) rotate(0deg);
            }
            50% {
                transform: scale(1.3) rotate(180deg);
                opacity: 0.8;
            }
            100% {
                transform: scale(0) rotate(360deg);
                opacity: 0;
            }
        }

        /* Modal base styles with proper z-index hierarchy */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            justify-content: center;
            align-items: center;
            z-index: 5000;
        }

        #levelModal {
            z-index: 5000;
        }

        #leaderboardModal {
            z-index: 6000;
        }

        #alertModal {
            z-index: 7000;
        }

        #resumeModal {
            z-index: 8000;
        }

        .modal-content {
            background: white;
            padding: 25px;
            border-radius: 15px;
            max-width: 700px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            animation: slideIn 0.3s;
            position: relative;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.5);
        }

        .alert-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 400px;
            width: 90%;
            animation: slideIn 0.3s;
            text-align: center;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.5);
        }

        .alert-content h3 {
            color: #764ba2;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .alert-content.warning h3 {
            color: #ff6b6b;
        }

        .alert-content.success h3 {
            color: #4CAF50;
        }

        .alert-content p {
            margin-bottom: 25px;
            color: #666;
            font-size: 1.1em;
            line-height: 1.5;
        }

        .alert-content button {
            min-width: 100px;
            padding: 10px 20px;
            margin: 0 5px;
        }

        .resume-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 30px;
            border-radius: 15px;
            max-width: 450px;
            width: 90%;
            animation: slideIn 0.3s;
            text-align: center;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.5);
        }

        .resume-content h3 {
            color: white;
            margin-bottom: 20px;
            font-size: 1.8em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .resume-content p {
            color: white;
            margin-bottom: 10px;
            font-size: 1.1em;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
        }

        .resume-content .game-info {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .resume-content button {
            background: white;
            color: #764ba2;
            margin: 5px;
            padding: 10px 20px;
            font-weight: bold;
        }

        .resume-content button:hover {
            background: #f0f0f0;
        }

        .resume-content button.new-game-btn {
            background: #ff6b6b;
            color: white;
        }

        .resume-content button.new-game-btn:hover {
            background: #ee5a24;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal h2 {
            color: #764ba2;
            margin-bottom: 20px;
            text-align: center;
        }

        .modal-close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #f44336;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .modal-close-btn:hover {
            background: #d32f2f;
            transform: rotate(90deg);
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin: 20px 0;
        }

        .level-btn {
            padding: 15px 10px;
            font-size: 16px;
            position: relative;
            min-height: 70px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .level-btn.completed {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
        }

        .level-btn .level-number {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .level-btn .best-score {
            font-size: 11px;
            opacity: 0.9;
            white-space: nowrap;
        }

        .leaderboard {
            margin-top: 20px;
        }

        .leaderboard-entry {
            display: grid;
            grid-template-columns: 40px 1fr auto;
            gap: 15px;
            padding: 12px;
            background: #f5f5f5;
            margin: 8px 0;
            border-radius: 8px;
            align-items: center;
            font-size: 14px;
        }

        .leaderboard-entry:nth-child(1) {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            font-weight: bold;
        }

        .leaderboard-entry:nth-child(2) {
            background: linear-gradient(135deg, #c0c0c0, #d8d8d8);
        }

        .leaderboard-entry:nth-child(3) {
            background: linear-gradient(135deg, #cd7f32, #e4a853);
        }

        .leaderboard-rank {
            font-weight: bold;
            text-align: center;
        }

        .leaderboard-stats {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .leaderboard-score {
            font-weight: bold;
            color: #764ba2;
        }

        .leaderboard-details {
            font-size: 12px;
            color: #666;
        }

        .leaderboard-date {
            text-align: right;
            font-size: 12px;
            color: #666;
            white-space: nowrap;
        }

        .hint-animation {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            }
        }

        .victory-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 40px;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border-radius: 20px;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.5);
            z-index: 4000;
            max-width: 500px;
            width: 90%;
            animation: victoryPop 0.5s ease-out;
        }

        @keyframes victoryPop {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .victory-message h2 {
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            color: white;
        }

        .victory-message p {
            margin: 15px 0;
            font-size: 1.3em;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
        }

        .victory-message .score-highlight {
            font-size: 1.8em;
            font-weight: bold;
            color: #ffeb3b;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.4);
        }

        .victory-message .button-group {
            margin-top: 30px;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .victory-message button {
            margin: 5px;
            background: white;
            color: #4CAF50;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
        }

        .victory-message button:hover {
            background: #f0f0f0;
        }

        .game-over-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 40px;
            background: linear-gradient(135deg, #f44336, #d32f2f);
            color: white;
            border-radius: 20px;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.5);
            z-index: 4000;
            max-width: 500px;
            width: 90%;
            animation: victoryPop 0.5s ease-out;
        }

        .game-over-message h2 {
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            color: white;
        }

        .game-over-message button {
            background: white;
            color: #f44336;
        }

        .game-over-message button:hover {
            background: #f0f0f0;
        }

        #timer {
            font-weight: bold;
            color: #764ba2;
        }

        @media (max-width: 768px) {
            .tile {
                width: 40px;
                height: 52px;
                font-size: 16px;
            }

            .game-board-container {
                padding: 10px;
            }

            .level-grid {
                grid-template-columns: repeat(4, 1fr);
            }

            .pause-message {
                padding: 30px 20px;
            }

            .pause-message h2 {
                font-size: 2em;
            }

            .leaderboard-entry {
                font-size: 12px;
            }

            .leaderboard-details {
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1>🀄 Mahjong Solitaire 🀄</h1>
            <div class="controls">
                <button onclick="game.newGame()">New Game</button>
                <button onclick="game.togglePause()" id="pauseBtn" class="pause-btn">Pause</button>
                <button onclick="game.showLevelSelect()">Select Level</button>
                <button onclick="game.showHint()" id="hintBtn">Hint (3)</button>
                <button onclick="game.shuffle()" id="shuffleBtn">Shuffle (2)</button>
                <button onclick="game.showLeaderboard()">Leaderboard</button>
            </div>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Level:</span>
                    <span id="currentLevel">1</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Score:</span>
                    <span id="score">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Moves:</span>
                    <span id="moves">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Time:</span>
                    <span id="timer">00:00</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Tiles:</span>
                    <span id="tilesLeft">0</span>
                </div>
            </div>
        </div>

        <div class="game-board-container">
            <div id="boardWrapper" class="board-wrapper">
                <div id="gameBoard"></div>
            </div>
        </div>
    </div>

    <!-- Pause Overlay (separate from game board) -->
    <div id="pauseOverlay" class="pause-overlay">
        <div class="pause-message">
            <h2>⏸️ Game Paused</h2>
            <p>Take a break! Your game is safely paused.</p>
            <button onclick="game.togglePause()">Resume Game</button>
        </div>
    </div>

    <!-- Resume Game Modal -->
    <div id="resumeModal" class="modal">
        <div class="resume-content">
            <h3>🎮 Continue Your Game?</h3>
            <p>You have an unfinished game!</p>
            <div class="game-info">
                <p><strong>Level:</strong> <span id="resumeLevel">1</span></p>
                <p><strong>Score:</strong> <span id="resumeScore">0</span></p>
                <p><strong>Time:</strong> <span id="resumeTime">00:00</span></p>
                <p><strong>Tiles Left:</strong> <span id="resumeTiles">0</span></p>
            </div>
            <button onclick="game.resumeSavedGame()">Continue Game</button>
            <button onclick="game.startFreshGame()" class="new-game-btn">Start New Game</button>
        </div>
    </div>

    <!-- Victory Modal -->
    <div id="victoryModal" class="victory-message" style="display: none;">
        <h2>🎉 Victory! 🎉</h2>
        <p>Level <span id="victoryLevel">1</span> Complete!</p>
        <p class="score-highlight">Score: <span id="victoryScore">0</span></p>
        <p>Time Bonus: <span id="victoryTimeBonus">0</span></p>
        <p>Moves: <span id="victoryMoves">0</span></p>
        <p>Time: <span id="victoryTime">00:00</span></p>
        <div class="button-group">
            <button onclick="game.nextLevel()">Next Level</button>
            <button onclick="game.newGame()">Replay Level</button>
            <button onclick="game.showLeaderboardFromVictory()">View Leaderboard</button>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="gameOverModal" class="game-over-message" style="display: none;">
        <h2>😔 Game Over 😔</h2>
        <p>No more valid moves!</p>
        <p class="score-highlight">Score: <span id="gameOverScore">0</span></p>
        <p>Moves: <span id="gameOverMoves">0</span></p>
        <div class="button-group">
            <button onclick="game.newGame()">Try Again</button>
            <button onclick="game.showLevelSelect()">Select Level</button>
        </div>
    </div>

    <!-- Level Select Modal -->
    <div id="levelModal" class="modal">
        <div class="modal-content">
            <button class="modal-close-btn" onclick="game.closeLevelSelect()">×</button>
            <h2>Select Level</h2>
            <div class="level-grid" id="levelGrid"></div>
            <button onclick="game.closeLevelSelect()">Close</button>
        </div>
    </div>

    <!-- Leaderboard Modal -->
    <div id="leaderboardModal" class="modal">
        <div class="modal-content">
            <button class="modal-close-btn" onclick="game.closeLeaderboard()">×</button>
            <h2>🏆 Leaderboard - Level <span id="leaderboardLevel">1</span></h2>
            <div class="leaderboard" id="leaderboardList"></div>
            <button onclick="game.closeLeaderboard()">Close</button>
        </div>
    </div>

    <!-- Alert Modal (replaces all alert() calls) -->
    <div id="alertModal" class="modal">
        <div class="alert-content" id="alertContent">
            <h3 id="alertTitle">Notice</h3>
            <p id="alertMessage">Message</p>
            <button onclick="game.closeAlert()">OK</button>
        </div>
    </div>

    <script>
        class MahjongGame {
            constructor() {
                this.currentLevel = 1;
                this.score = 0;
                this.moves = 0;
                this.hints = 3;
                this.shuffles = 2;
                this.tiles = [];
                this.selectedTile = null;
                this.gameBoard = document.getElementById('gameBoard');
                this.boardWrapper = document.getElementById('boardWrapper');
                this.boardContainer = document.querySelector('.game-board-container');
                this.header = document.querySelector('.game-header');
                this.startTime = null;
                this.timerInterval = null;
                this.gameActive = false;
                this.isPaused = false;
                this.pausedTime = 0;
                this.totalPausedDuration = 0; // Track total time spent paused
                this.autoSaveInterval = null;
                this.initialTileCount = 0; // Track initial number of tiles for time bonus calculation
                
                this.symbols = [
                    '🀄', '🎋', '🎍', '🌸', '🌺', '🌻', '🌷', '🌹',
                    '🦋', '🐉', '🦅', '🐢', '🎯', '⭐', '💎', '🔮',
                    '🎨', '🎭', '🎪', '🎰', '♠', '♥', '♦', '♣',
                    '🔵', '🔴', '🟢', '🟡', '🟣', '🟠', '⚫', '⚪'
                ];
                
                this.layouts = this.generateLayouts();
                this.loadGameData();
                this.init();

                window.addEventListener('resize', () => this.refit());
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => this.refit(), 50);
                });

                // Auto-save every 5 seconds when game is active
                this.startAutoSave();

                // Save game state before page unload
                window.addEventListener('beforeunload', () => {
                    if (this.gameActive && this.tiles.length > 0) {
                        this.saveGameState();
                    }
                });
            }

            calculateTimeBonus(timeElapsed, tileCount) {
                // Base time allowance: 1.2 seconds per tile for perfect score
                // This gives players reasonable time based on puzzle complexity
                const baseTimePerTile = 1.2; // seconds
                const perfectTime = tileCount * baseTimePerTile;
                
                // Maximum bonus is based on tile count
                // More tiles = higher potential bonus
                const maxBonus = tileCount * 50; // 50 points per tile maximum
                
                // Calculate bonus with a more generous curve
                let bonus = 0;
                
                if (timeElapsed <= perfectTime) {
                    // Full bonus for perfect time or better
                    bonus = maxBonus;
                } else if (timeElapsed <= perfectTime * 1.5) {
                    // 75% bonus for up to 50% over perfect time
                    const ratio = (perfectTime * 1.5 - timeElapsed) / (perfectTime * 0.5);
                    bonus = Math.floor(maxBonus * 0.75 * ratio + maxBonus * 0.25);
                } else if (timeElapsed <= perfectTime * 2) {
                    // 25-75% bonus for 50-100% over perfect time
                    const ratio = (perfectTime * 2 - timeElapsed) / (perfectTime * 0.5);
                    bonus = Math.floor(maxBonus * 0.25 * ratio);
                } else if (timeElapsed <= perfectTime * 3) {
                    // Small bonus (up to 25%) for 100-200% over perfect time
                    const ratio = (perfectTime * 3 - timeElapsed) / perfectTime;
                    bonus = Math.floor(maxBonus * 0.1 * ratio);
                } else {
                    // No bonus for very slow completion
                    bonus = 0;
                }
                
                // Ensure bonus is never negative
                return Math.max(0, bonus);
            }

            startAutoSave() {
                this.autoSaveInterval = setInterval(() => {
                    if (this.gameActive && this.tiles.length > 0) {
                        this.saveGameState();
                    }
                }, 5000); // Save every 5 seconds
            }

            saveGameState() {
                if (!this.gameActive || this.tiles.length === 0) return;

                // Calculate actual elapsed time excluding pauses
                const actualElapsedTime = this.getActualElapsedTime();

                const gameState = {
                    level: this.currentLevel,
                    score: this.score,
                    moves: this.moves,
                    hints: this.hints,
                    shuffles: this.shuffles,
                    elapsedTime: actualElapsedTime, // Save the actual game time
                    isPaused: this.isPaused,
                    initialTileCount: this.initialTileCount,
                    tiles: [],
                    timestamp: Date.now()
                };

                // Save tile positions and states
                this.tiles.forEach(tile => {
                    if (!tile.classList.contains('matched')) {
                        gameState.tiles.push({
                            id: tile.dataset.id,
                            value: tile.dataset.value,
                            x: tile.style.left,
                            y: tile.style.top,
                            z: tile.dataset.z,
                            originalX: tile.dataset.x,
                            originalY: tile.dataset.y,
                            selected: tile.classList.contains('selected')
                        });
                    }
                });

                try {
                    localStorage.setItem('mahjongCurrentGame', JSON.stringify(gameState));
                } catch (e) {
                    console.error('Failed to save game state:', e);
                }
            }

            getActualElapsedTime() {
                if (!this.startTime) return 0;
                
                let elapsed;
                if (this.isPaused) {
                    // If currently paused, use the time when pause started
                    elapsed = this.pausedTime - this.startTime - this.totalPausedDuration;
                } else {
                    // If not paused, calculate current elapsed time minus total paused duration
                    elapsed = Date.now() - this.startTime - this.totalPausedDuration;
                }
                
                return Math.floor(elapsed / 1000); // Return in seconds
            }

            loadSavedGame() {
                try {
                    const saved = localStorage.getItem('mahjongCurrentGame');
                    if (saved) {
                        return JSON.parse(saved);
                    }
                } catch (e) {
                    console.error('Failed to load saved game:', e);
                }
                return null;
            }

            clearSavedGame() {
                try {
                    localStorage.removeItem('mahjongCurrentGame');
                } catch (e) {
                    console.error('Failed to clear saved game:', e);
                }
            }

            checkForSavedGame() {
                const savedGame = this.loadSavedGame();
                if (savedGame && savedGame.tiles && savedGame.tiles.length > 0) {
                    // Check if saved game is not too old (100 days)
                    const hoursSinceLastSave = (Date.now() - savedGame.timestamp) / (1000 * 60 * 60);
                    if (hoursSinceLastSave < 24 * 100) {
                        this.showResumeModal(savedGame);
                        return true;
                    } else {
                        this.clearSavedGame();
                    }
                }
                return false;
            }

            showResumeModal(savedGame) {
                document.getElementById('resumeLevel').textContent = savedGame.level;
                document.getElementById('resumeScore').textContent = savedGame.score.toLocaleString();
                document.getElementById('resumeTime').textContent = this.formatTime(savedGame.elapsedTime);
                document.getElementById('resumeTiles').textContent = savedGame.tiles.length;
                document.getElementById('resumeModal').style.display = 'flex';
            }

            resumeSavedGame() {
                const savedGame = this.loadSavedGame();
                if (!savedGame) {
                    this.startFreshGame();
                    return;
                }

                // Restore game state
                this.currentLevel = savedGame.level;
                this.score = savedGame.score;
                this.moves = savedGame.moves;
                this.hints = savedGame.hints;
                this.shuffles = savedGame.shuffles;
                this.initialTileCount = savedGame.initialTileCount || savedGame.tiles.length;
                this.gameActive = true;
                this.selectedTile = null;
                this.totalPausedDuration = 0;

                // Set up timer with saved elapsed time
                const savedElapsedMs = savedGame.elapsedTime * 1000;
                this.startTime = Date.now() - savedElapsedMs;

                // Always start unpaused when resuming a saved game
                this.isPaused = false;
                const pauseBtn = document.getElementById('pauseBtn');
                pauseBtn.textContent = 'Pause';
                pauseBtn.classList.remove('paused');
                document.getElementById('pauseOverlay').classList.remove('active');

                // Clear board and restore tiles
                this.gameBoard.innerHTML = '';
                this.tiles = [];

                savedGame.tiles.forEach(tileData => {
                    const tile = document.createElement('div');
                    tile.className = 'tile';
                    if (tileData.selected) {
                        tile.classList.add('selected');
                    }
                    tile.textContent = tileData.value;
                    tile.style.left = tileData.x;
                    tile.style.top = tileData.y;
                    tile.style.zIndex = tileData.z * 100 + Math.floor(parseFloat(tileData.y) / 10);
                    
                    tile.dataset.id = tileData.id;
                    tile.dataset.value = tileData.value;
                    tile.dataset.x = tileData.originalX;
                    tile.dataset.y = tileData.originalY;
                    tile.dataset.z = tileData.z;
                    
                    tile.onclick = () => this.selectTile(tile);
                    
                    this.gameBoard.appendChild(tile);
                    this.tiles.push(tile);

                    if (tileData.selected) {
                        this.selectedTile = tile;
                    }
                });

                // Update UI
                this.updateStats();
                this.updateButtons();
                this.fitBoardToTiles();
                this.scaleBoardToContainer();
                this.updateTileStates();

                // Update timer display
                document.getElementById('timer').textContent = this.formatTime(savedGame.elapsedTime);

                // Start timer (game always resumes unpaused)
                this.startTimer();

                // Close modal
                document.getElementById('resumeModal').style.display = 'none';

                // Clear saved game after loading
                this.clearSavedGame();
            }

            startFreshGame() {
                this.clearSavedGame();
                document.getElementById('resumeModal').style.display = 'none';
                this.newGame();
            }

            formatDate(timestamp) {
                const date = new Date(timestamp);
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                
                const dateToCheck = new Date(date.getFullYear(), date.getMonth(), date.getDate());
                
                if (dateToCheck.getTime() === today.getTime()) {
                    return 'Today';
                } else if (dateToCheck.getTime() === yesterday.getTime()) {
                    return 'Yesterday';
                } else {
                    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    const dayDiff = Math.floor((now - date) / (1000 * 60 * 60 * 24));
                    
                    if (dayDiff < 7) {
                        return `${dayDiff} days ago`;
                    } else if (date.getFullYear() === now.getFullYear()) {
                        return `${months[date.getMonth()]} ${date.getDate()}`;
                    } else {
                        return `${months[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
                    }
                }
            }

            formatTime(seconds) {
                const minutes = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }

            showAlert(title, message, type = 'info') {
                const modal = document.getElementById('alertModal');
                const alertTitle = document.getElementById('alertTitle');
                const alertMessage = document.getElementById('alertMessage');
                const alertContent = document.getElementById('alertContent');
                
                alertTitle.textContent = title;
                alertMessage.textContent = message;
                
                alertContent.classList.remove('warning', 'success');
                
                if (type === 'warning') {
                    alertContent.classList.add('warning');
                } else if (type === 'success') {
                    alertContent.classList.add('success');
                }
                
                modal.style.display = 'flex';
            }

            closeAlert() {
                document.getElementById('alertModal').style.display = 'none';
            }

            generateLayouts() {
                const layouts = [];
                const layoutPatterns = [
                    { rows: 4, cols: 8, layers: 1, pattern: 'rectangle' },
                    { rows: 5, cols: 8, layers: 1, pattern: 'rectangle' },
                    { rows: 4, cols: 10, layers: 1, pattern: 'rectangle' },
                    { rows: 5, cols: 10, layers: 1, pattern: 'diamond' },
                    { rows: 6, cols: 10, layers: 1, pattern: 'diamond' },
                    { rows: 6, cols: 12, layers: 2, pattern: 'pyramid' },
                    { rows: 6, cols: 12, layers: 2, pattern: 'pyramid' },
                    { rows: 7, cols: 12, layers: 2, pattern: 'butterfly' },
                    { rows: 7, cols: 14, layers: 2, pattern: 'butterfly' },
                    { rows: 8, cols: 14, layers: 2, pattern: 'cross' },
                    { rows: 8, cols: 14, layers: 3, pattern: 'fortress' },
                    { rows: 8, cols: 16, layers: 3, pattern: 'fortress' },
                    { rows: 9, cols: 16, layers: 3, pattern: 'dragon' },
                    { rows: 9, cols: 16, layers: 3, pattern: 'dragon' },
                    { rows: 9, cols: 18, layers: 3, pattern: 'temple' },
                    { rows: 10, cols: 18, layers: 4, pattern: 'temple' },
                    { rows: 10, cols: 18, layers: 4, pattern: 'arena' },
                    { rows: 10, cols: 20, layers: 4, pattern: 'arena' },
                    { rows: 11, cols: 20, layers: 4, pattern: 'turtle' },
                    { rows: 11, cols: 20, layers: 5, pattern: 'turtle' }
                ];
                layoutPatterns.forEach((config, index) => {
                    layouts.push(this.createLayout(index + 1, config));
                });
                return layouts;
            }

            createLayout(level, config) {
                const positions = [];
                const { rows, cols, layers, pattern } = config;
                
                for (let layer = 0; layer < layers; layer++) {
                    const layerReduction = layer * 2;
                    const layerRows = Math.max(2, rows - layerReduction);
                    const layerCols = Math.max(4, cols - layerReduction);
                    const offsetX = layer * 25;
                    const offsetY = layer * 20;
                    
                    for (let row = 0; row < layerRows; row++) {
                        for (let col = 0; col < layerCols; col++) {
                            if (this.shouldPlaceTile(pattern, row, col, layerRows, layerCols, layer)) {
                                positions.push({
                                    x: col * 52 + offsetX + 50,
                                    y: row * 67 + offsetY + 50,
                                    z: layer
                                });
                            }
                        }
                    }
                }
                
                if (positions.length % 2 !== 0) positions.pop();
                return positions;
            }

            shouldPlaceTile(pattern, row, col, rows, cols, layer) {
                const centerRow = rows / 2;
                const centerCol = cols / 2;
                
                switch(pattern) {
                    case 'rectangle':
                        return true;
                    case 'diamond':
                        return Math.abs(row - centerRow) + Math.abs(col - centerCol) <= (rows + cols) / 4;
                    case 'pyramid':
                        return row >= Math.abs(col - centerCol) / 3;
                    case 'butterfly':
                        return Math.abs(col - centerCol) > 1 || Math.abs(row - centerRow) < 2;
                    case 'cross':
                        return Math.abs(row - centerRow) < 2 || Math.abs(col - centerCol) < 2;
                    case 'fortress': {
                        const edge = row === 0 || row === rows - 1 || col === 0 || col === cols - 1;
                        const center = Math.abs(row - centerRow) < 2 && Math.abs(col - centerCol) < 2;
                        return edge || center || (layer > 0 && Math.random() > 0.3);
                    }
                    case 'dragon': {
                        const wave = Math.sin(col / 2) * 2;
                        return Math.abs(row - centerRow - wave) < 3;
                    }
                    case 'temple': {
                        const templeShape = row < rows / 3 || 
                          (row < 2 * rows / 3 && Math.abs(col - centerCol) < cols / 3) ||
                          Math.abs(col - centerCol) < 2;
                        return templeShape || (layer > 0 && Math.random() > 0.4);
                    }
                    case 'arena': {
                        const ring = Math.abs(row - centerRow) > 1 || Math.abs(col - centerCol) > 1;
                        const filled = layer > 0 && Math.abs(row - centerRow) < 3 && Math.abs(col - centerCol) < 3;
                        return ring || filled;
                    }
                    case 'turtle': {
                        const dist = Math.sqrt(Math.pow(row - centerRow, 2) + Math.pow(col - centerCol, 2));
                        return dist <= Math.min(rows, cols) / 2 || (layer > 0 && dist <= Math.min(rows, cols) / 3);
                    }
                    default:
                        return true;
                }
            }

            init() {
                this.createLevelGrid();
                
                // Check for saved game on init
                if (!this.checkForSavedGame()) {
                    this.newGame();
                }
            }

            createLevelGrid() {
                const grid = document.getElementById('levelGrid');
                grid.innerHTML = '';
                
                for (let i = 1; i <= 20; i++) {
                    const btn = document.createElement('button');
                    btn.className = 'level-btn';
                    
                    const levelNumber = document.createElement('div');
                    levelNumber.className = 'level-number';
                    levelNumber.textContent = i;
                    btn.appendChild(levelNumber);
                    
                    const levelData = this.getLevelData(i);
                    if (levelData && levelData.completed) {
                        btn.classList.add('completed');
                        const scoreDiv = document.createElement('div');
                        scoreDiv.className = 'best-score';
                        scoreDiv.textContent = `Best: ${levelData.bestScore.toLocaleString()}`;
                        btn.appendChild(scoreDiv);
                    }
                    
                    btn.onclick = () => this.selectLevel(i);
                    grid.appendChild(btn);
                }
            }

            togglePause() {
                if (!this.gameActive || this.tiles.length === 0) return;
                
                this.isPaused = !this.isPaused;
                const pauseBtn = document.getElementById('pauseBtn');
                const pauseOverlay = document.getElementById('pauseOverlay');
                
                if (this.isPaused) {
                    // Record when pause started
                    this.pausedTime = Date.now();
                    pauseBtn.textContent = 'Resume';
                    pauseBtn.classList.add('paused');
                    pauseOverlay.classList.add('active');
                    clearInterval(this.timerInterval);
                    this.saveGameState(); // Save when pausing
                } else {
                    // Calculate how long the game was paused and add to total
                    const pauseDuration = Date.now() - this.pausedTime;
                    this.totalPausedDuration += pauseDuration;
                    
                    pauseBtn.textContent = 'Pause';
                    pauseBtn.classList.remove('paused');
                    pauseOverlay.classList.remove('active');
                    this.startTimer();
                }
            }

            newGame() {
                // Clear any saved game when starting a new game
                this.clearSavedGame();
                
                this.score = 0;
                this.moves = 0;
                this.hints = 3;
                this.shuffles = 2;
                this.selectedTile = null;
                this.gameActive = true;
                this.isPaused = false;
                this.startTime = null;
                this.pausedTime = 0;
                this.totalPausedDuration = 0;
                
                clearInterval(this.timerInterval);
                document.getElementById('timer').textContent = '00:00';
                
                const pauseBtn = document.getElementById('pauseBtn');
                pauseBtn.textContent = 'Pause';
                pauseBtn.classList.remove('paused');
                document.getElementById('pauseOverlay').classList.remove('active');
                
                document.getElementById('victoryModal').style.display = 'none';
                document.getElementById('gameOverModal').style.display = 'none';
                
                this.updateStats();
                this.createBoard();
                this.startTimer();
                this.updateButtons();
            }

            createBoard() {
                this.gameBoard.innerHTML = '';
                this.tiles = [];
                
                const layout = this.layouts[this.currentLevel - 1];
                const numPairs = Math.floor(layout.length / 2);
                
                // Store initial tile count for time bonus calculation
                this.initialTileCount = layout.length;
                
                const tileValues = [];
                for (let i = 0; i < numPairs; i++) {
                    const symbol = this.symbols[i % this.symbols.length];
                    tileValues.push(symbol, symbol);
                }
                
                for (let i = tileValues.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [tileValues[i], tileValues[j]] = [tileValues[j], tileValues[i]];
                }
                
                layout.forEach((pos, index) => {
                    const tile = document.createElement('div');
                    tile.className = 'tile';
                    tile.textContent = tileValues[index];
                    tile.style.left = pos.x + 'px';
                    tile.style.top = pos.y + 'px';
                    tile.style.zIndex = pos.z * 100 + Math.floor(pos.y / 10);
                    
                    tile.dataset.id = index;
                    tile.dataset.value = tileValues[index];
                    tile.dataset.x = pos.x;
                    tile.dataset.y = pos.y;
                    tile.dataset.z = pos.z;
                    
                    tile.onclick = () => this.selectTile(tile);
                    
                    this.gameBoard.appendChild(tile);
                    this.tiles.push(tile);
                });

                this.fitBoardToTiles();
                this.scaleBoardToContainer();
                this.updateTileStates();
                document.getElementById('tilesLeft').textContent = this.tiles.length;
            }

            fitBoardToTiles() {
                if (!this.tiles.length) {
                    this.gameBoard.style.width = '900px';
                    this.gameBoard.style.height = '600px';
                    return;
                }

                const sampleTile = this.tiles[0];
                const tileW = sampleTile.offsetWidth || 50;
                const tileH = sampleTile.offsetHeight || 65;

                const isMobile = window.innerWidth <= 768;
                const padding = Math.max(10, Math.round(tileW * (isMobile ? 0.6 : 0.4)));

                let useStyle = !!this.tiles[0].style.left;
                let minX = Infinity, minY = Infinity;

                this.tiles.forEach(t => {
                    const x = useStyle ? parseFloat(t.style.left) : parseFloat(t.dataset.x);
                    const y = useStyle ? parseFloat(t.style.top) : parseFloat(t.dataset.y);
                    if (x < minX) minX = x;
                    if (y < minY) minY = y;
                });

                this.tiles.forEach(t => {
                    const x0 = useStyle ? parseFloat(t.style.left) : parseFloat(t.dataset.x);
                    const y0 = useStyle ? parseFloat(t.style.top) : parseFloat(t.dataset.y);
                    const nx = x0 - minX + padding;
                    const ny = y0 - minY + padding;
                    t.style.left = nx + 'px';
                    t.style.top = ny + 'px';
                    const z = parseInt(t.dataset.z);
                    t.style.zIndex = z * 100 + Math.floor(ny / 10);
                });

                let maxRight = 0, maxBottom = 0;
                this.tiles.forEach(t => {
                    const left = parseFloat(t.style.left);
                    const top = parseFloat(t.style.top);
                    const right = left + (t.offsetWidth || tileW);
                    const bottom = top + (t.offsetHeight || tileH);
                    if (right > maxRight) maxRight = right;
                    if (bottom > maxBottom) maxBottom = bottom;
                });

                const boardWidth = Math.ceil(maxRight + padding);
                const boardHeight = Math.ceil(maxBottom + padding);

                this.gameBoard.style.width = boardWidth + 'px';
                this.gameBoard.style.height = boardHeight + 'px';

                this._boardNaturalSize = { width: boardWidth, height: boardHeight };
            }

            scaleBoardToContainer() {
                if (!this._boardNaturalSize) return;

                const boardWidth = this._boardNaturalSize.width;
                const boardHeight = this._boardNaturalSize.height;

                const cs = getComputedStyle(this.boardContainer);
                const padX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
                const padY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);
                const availableWidth = Math.max(100, this.boardContainer.clientWidth - padX);

                const headerH = this.header ? this.header.offsetHeight : 0;
                const availableHeight = Math.max(150, window.innerHeight - headerH - 40);

                const scale = Math.min(1, availableWidth / boardWidth, availableHeight / boardHeight);

                this.gameBoard.style.transform = `scale(${scale})`;
                this.boardWrapper.style.width = (boardWidth * scale) + 'px';
                this.boardWrapper.style.height = (boardHeight * scale) + 'px';
            }

            refit() {
                if (!this.tiles.length) return;
                this.fitBoardToTiles();
                this.scaleBoardToContainer();
                this.updateTileStates();
            }

            updateTileStates() {
                this.tiles.forEach(tile => {
                    if (!tile.classList.contains('matched')) {
                        if (this.isTileBlocked(tile)) {
                            tile.classList.add('blocked');
                        } else {
                            tile.classList.remove('blocked');
                        }
                    }
                });
            }

            isTileBlocked(tile) {
                if (tile.classList.contains('matched')) return true;
                
                const x = parseFloat(tile.style.left);
                const y = parseFloat(tile.style.top);
                const z = parseInt(tile.dataset.z);

                const tileW = tile.offsetWidth || 50;
                const tileH = tile.offsetHeight || 65;
                
                const hasTopTile = this.tiles.some(t => {
                    if (t === tile || t.classList.contains('matched')) return false;
                    const tx = parseFloat(t.style.left);
                    const ty = parseFloat(t.style.top);
                    const tz = parseInt(t.dataset.z);
                    return tz > z && Math.abs(tx - x) < (tileW - 10) && Math.abs(ty - y) < (tileH - 10);
                });
                if (hasTopTile) return true;
                
                let leftBlocked = false;
                let rightBlocked = false;
                
                this.tiles.forEach(t => {
                    if (t === tile || t.classList.contains('matched')) return;
                    const tx = parseFloat(t.style.left);
                    const ty = parseFloat(t.style.top);
                    const tz = parseInt(t.dataset.z);
                    
                    if (tz === z && Math.abs(ty - y) < Math.floor(tileH / 2)) {
                        if (tx < x && x - tx < tileW + 2) leftBlocked = true;
                        if (tx > x && tx - x < tileW + 2) rightBlocked = true;
                    }
                });
                
                return leftBlocked && rightBlocked;
            }

            selectTile(tile) {
                if (!this.gameActive || this.isPaused || tile.classList.contains('blocked') || tile.classList.contains('matched')) {
                    return;
                }
                
                if (this.selectedTile === tile) {
                    tile.classList.remove('selected');
                    this.selectedTile = null;
                    return;
                }
                
                if (this.selectedTile) {
                    if (this.selectedTile.dataset.value === tile.dataset.value) {
                        this.matchTiles(this.selectedTile, tile);
                    } else {
                        this.selectedTile.classList.remove('selected');
                        this.selectedTile = tile;
                        tile.classList.add('selected');
                    }
                } else {
                    this.selectedTile = tile;
                    tile.classList.add('selected');
                }
            }

            matchTiles(tile1, tile2) {
                tile1.classList.add('matched');
                tile2.classList.add('matched');
                tile1.classList.remove('selected');
                tile2.classList.remove('selected');
                
                this.score += 100 + (this.hints * 10) + (this.shuffles * 20);
                this.moves++;
                this.selectedTile = null;
                
                setTimeout(() => {
                    tile1.style.display = 'none';
                    tile2.style.display = 'none';
                    
                    this.tiles = this.tiles.filter(t => t !== tile1 && t !== tile2);
                    this.updateTileStates();
                    this.updateStats();
                    
                    if (this.tiles.length === 0) {
                        this.victory();
                    } else if (!this.hasValidMoves()) {
                        this.gameOver();
                    }
                }, 500);
            }

            hasValidMoves() {
                const availableTiles = this.tiles.filter(t => 
                    !t.classList.contains('blocked') && !t.classList.contains('matched')
                );
                
                for (let i = 0; i < availableTiles.length; i++) {
                    for (let j = i + 1; j < availableTiles.length; j++) {
                        if (availableTiles[i].dataset.value === availableTiles[j].dataset.value) {
                            return true;
                        }
                    }
                }
                return false;
            }

            showHint() {
                if (this.hints <= 0 || !this.gameActive || this.isPaused) return;
                
                const availableTiles = this.tiles.filter(t => 
                    !t.classList.contains('blocked') && !t.classList.contains('matched')
                );
                
                for (let i = 0; i < availableTiles.length; i++) {
                    for (let j = i + 1; j < availableTiles.length; j++) {
                        if (availableTiles[i].dataset.value === availableTiles[j].dataset.value) {
                            availableTiles[i].classList.add('hint-animation');
                            availableTiles[j].classList.add('hint-animation');
                            
                            setTimeout(() => {
                                availableTiles[i].classList.remove('hint-animation');
                                availableTiles[j].classList.remove('hint-animation');
                            }, 2000);
                            
                            this.hints--;
                            this.score = Math.max(0, this.score - 50);
                            this.updateStats();
                            this.updateButtons();
                            return;
                        }
                    }
                }
                
                this.showAlert('No Moves', 'No valid moves available! Try shuffling the tiles.', 'warning');
            }

            shuffle() {
                if (this.shuffles <= 0 || !this.gameActive || this.isPaused) return;
                
                const activeTiles = this.tiles.filter(t => !t.classList.contains('matched'));
                const values = activeTiles.map(t => t.dataset.value);
                
                for (let i = values.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [values[i], values[j]] = [values[j], values[i]];
                }
                
                activeTiles.forEach((tile, index) => {
                    tile.dataset.value = values[index];
                    tile.textContent = values[index];
                    tile.classList.remove('selected');
                });
                
                this.selectedTile = null;
                this.shuffles--;
                this.score = Math.max(0, this.score - 100);
                this.updateTileStates();
                this.updateStats();
                this.updateButtons();

                this.refit();
                
                if (!this.hasValidMoves()) {
                    setTimeout(() => {
                        if (this.shuffles > 0) {
                            this.showAlert('Auto Shuffle', 'No valid moves after shuffle. Shuffling again...', 'warning');
                            setTimeout(() => {
                                this.closeAlert();
                                this.shuffle();
                            }, 2000);
                        } else {
                            this.gameOver();
                        }
                    }, 500);
                }
            }

            updateButtons() {
                document.getElementById('hintBtn').textContent = `Hint (${this.hints})`;
                document.getElementById('hintBtn').disabled = this.hints <= 0;
                
                document.getElementById('shuffleBtn').textContent = `Shuffle (${this.shuffles})`;
                document.getElementById('shuffleBtn').disabled = this.shuffles <= 0;
            }

            startTimer() {
                if (!this.gameActive) return;
                
                if (!this.startTime) {
                    this.startTime = Date.now();
                }
                
                clearInterval(this.timerInterval);
                
                this.timerInterval = setInterval(() => {
                    if (this.gameActive && !this.isPaused) {
                        const elapsed = this.getActualElapsedTime();
                        document.getElementById('timer').textContent = this.formatTime(elapsed);
                    }
                }, 1000);
            }

            updateStats() {
                document.getElementById('currentLevel').textContent = this.currentLevel;
                document.getElementById('score').textContent = this.score;
                document.getElementById('moves').textContent = this.moves;
                document.getElementById('tilesLeft').textContent = this.tiles.filter(t => !t.classList.contains('matched')).length;
            }

            victory() {
                this.gameActive = false;
                clearInterval(this.timerInterval);
                this.clearSavedGame(); // Clear saved game on victory
                
                const timeElapsed = this.getActualElapsedTime();
                const timeBonus = this.calculateTimeBonus(timeElapsed, this.initialTileCount);
                const finalScore = Math.floor(this.score + timeBonus);
                
                this.saveLevelData(this.currentLevel, finalScore, timeElapsed, this.moves);
                this.updateLeaderboard(this.currentLevel, finalScore, timeElapsed, this.moves);
                
                // Update victory modal content
                document.getElementById('victoryLevel').textContent = this.currentLevel;
                document.getElementById('victoryScore').textContent = finalScore.toLocaleString();
                document.getElementById('victoryTimeBonus').textContent = timeBonus.toLocaleString();
                document.getElementById('victoryMoves').textContent = this.moves;
                document.getElementById('victoryTime').textContent = this.formatTime(timeElapsed);
                
                // Show victory modal
                document.getElementById('victoryModal').style.display = 'block';
                
                // Refresh level grid to show updated scores
                this.createLevelGrid();
            }

            gameOver() {
                this.gameActive = false;
                clearInterval(this.timerInterval);
                this.clearSavedGame(); // Clear saved game on game over
                
                document.getElementById('gameOverScore').textContent = this.score;
                document.getElementById('gameOverMoves').textContent = this.moves;
                
                document.getElementById('gameOverModal').style.display = 'block';
            }

            nextLevel() {
                document.getElementById('victoryModal').style.display = 'none';
                if (this.currentLevel < 20) {
                    this.currentLevel++;
                    this.newGame();
                } else {
                    this.showAlert('Congratulations!', '🏆 You have completed all 20 levels! You are a Mahjong Master! 🏆', 'success');
                    setTimeout(() => {
                        this.closeAlert();
                        this.showLevelSelect();
                    }, 3000);
                }
            }

            selectLevel(level) {
                this.currentLevel = level;
                this.closeLevelSelect();
                this.newGame();
            }

            showLevelSelect() {
                document.getElementById('levelModal').style.display = 'flex';
                this.createLevelGrid();
            }

            closeLevelSelect() {
                document.getElementById('levelModal').style.display = 'none';
            }

            showLeaderboard() {
                document.getElementById('leaderboardModal').style.display = 'flex';
                document.getElementById('leaderboardLevel').textContent = this.currentLevel;
                this.displayLeaderboard(this.currentLevel);
            }

            showLeaderboardFromVictory() {
                this.showLeaderboard();
            }

            closeLeaderboard() {
                document.getElementById('leaderboardModal').style.display = 'none';
            }

            displayLeaderboard(level) {
                const leaderboard = this.getLeaderboard(level);
                const list = document.getElementById('leaderboardList');
                list.innerHTML = '';
                
                if (leaderboard.length === 0) {
                    list.innerHTML = '<p style="text-align: center; padding: 20px;">No scores yet for this level!</p>';
                    return;
                }
                
                leaderboard.forEach((entry, index) => {
                    const div = document.createElement('div');
                    div.className = 'leaderboard-entry';
                    
                    const rankDiv = document.createElement('div');
                    rankDiv.className = 'leaderboard-rank';
                    rankDiv.innerHTML = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `${index + 1}`;
                    
                    const statsDiv = document.createElement('div');
                    statsDiv.className = 'leaderboard-stats';
                    statsDiv.innerHTML = `
                        <div class="leaderboard-score">Score: ${entry.score.toLocaleString()}</div>
                        <div class="leaderboard-details">Time: ${this.formatTime(entry.time || 0)} | Moves: ${entry.moves || 0}</div>
                    `;
                    
                    const dateDiv = document.createElement('div');
                    dateDiv.className = 'leaderboard-date';
                    dateDiv.textContent = this.formatDate(entry.date);
                    
                    div.appendChild(rankDiv);
                    div.appendChild(statsDiv);
                    div.appendChild(dateDiv);
                    
                    list.appendChild(div);
                });
            }

            loadGameData() {
                const saved = localStorage.getItem('mahjongGameData');
                if (saved) {
                    try {
                        this.gameData = JSON.parse(saved);
                    } catch (e) {
                        this.gameData = { levels: {}, leaderboards: {} };
                    }
                } else {
                    this.gameData = { levels: {}, leaderboards: {} };
                }
            }

            saveGameData() {
                try {
                    localStorage.setItem('mahjongGameData', JSON.stringify(this.gameData));
                } catch (e) {
                    console.error('Failed to save game data:', e);
                }
            }

            saveLevelData(level, score, time, moves) {
                if (!this.gameData.levels[level]) {
                    this.gameData.levels[level] = {
                        completed: false,
                        bestScore: 0,
                        bestTime: null,
                        bestMoves: null,
                        attempts: 0
                    };
                }
                
                this.gameData.levels[level].completed = true;
                this.gameData.levels[level].attempts++;
                if (score > this.gameData.levels[level].bestScore) {
                    this.gameData.levels[level].bestScore = score;
                    this.gameData.levels[level].bestTime = time;
                    this.gameData.levels[level].bestMoves = moves;
                }
                
                this.saveGameData();
            }

            getLevelData(level) {
                return this.gameData.levels[level] || null;
            }

            updateLeaderboard(level, score, time, moves) {
                if (!this.gameData.leaderboards[level]) {
                    this.gameData.leaderboards[level] = [];
                }
                
                this.gameData.leaderboards[level].push({
                    score: score,
                    time: time,
                    moves: moves,
                    date: Date.now()
                });
                
                this.gameData.leaderboards[level].sort((a, b) => b.score - a.score);
                this.gameData.leaderboards[level] = this.gameData.leaderboards[level].slice(0, 10);
                
                this.saveGameData();
            }

            getLeaderboard(level) {
                return this.gameData.leaderboards[level] || [];
            }
        }

        const game = new MahjongGame();
    </script>
</body>
</html>