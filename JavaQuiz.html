<!DOCTYPE html>
<!-- MIT License
Copyright (c) 2025-2026 Valentyn Kolesnikov <0009-0003-9608-3364@orcid.org>
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Java Quiz">
    <title>Java Quiz</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f89820 0%, #5382a1 50%, #0d1117 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .quiz-container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .quiz-header {
            background: linear-gradient(135deg, #f89820, #5382a1);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .quiz-header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .quiz-header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .progress-container {
            background: #f0f0f0;
            padding: 15px 30px;
            border-bottom: 1px solid #ddd;
        }

        .progress-bar {
            height: 10px;
            background: #e0e0e0;
            border-radius: 5px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #f89820, #5382a1);
            border-radius: 5px;
            transition: width 0.3s ease;
        }

        .progress-text {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #666;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 10px;
        }

        .timer-container {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: bold;
        }

        .timer-icon {
            font-size: 1.2rem;
        }

        .timer {
            font-size: 1.1rem;
            color: #f89820;
            font-family: 'Courier New', monospace;
        }

        .timer.warning {
            color: #ff6b00;
            animation: pulse 1s infinite;
        }

        .timer.danger {
            color: #dc3545;
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .quiz-content {
            padding: 30px;
        }

        .question-card {
            display: none;
        }

        .question-card.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .question-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .question-number {
            color: #f89820;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .question-category {
            background: linear-gradient(135deg, #f89820, #5382a1);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.8rem;
        }

        .question-difficulty {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .question-difficulty.easy {
            background: #d4edda;
            color: #155724;
        }

        .question-difficulty.medium {
            background: #fff3cd;
            color: #856404;
        }

        .question-difficulty.hard {
            background: #f8d7da;
            color: #721c24;
        }

        .question-text {
            font-size: 1.3rem;
            color: #333;
            margin-bottom: 25px;
            line-height: 1.5;
        }

        .time-up-message {
            background: linear-gradient(135deg, #dc3545, #c82333);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
            align-items: center;
            gap: 10px;
            animation: fadeIn 0.3s ease;
        }

        .time-up-message.show {
            display: flex;
        }

        .time-up-message .time-icon {
            font-size: 1.5rem;
        }

        .time-up-message .time-text {
            flex: 1;
        }

        .time-up-message .time-text strong {
            display: block;
            font-size: 1.1rem;
            margin-bottom: 2px;
        }

        .time-up-message .time-text span {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .option {
            padding: 15px 20px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            background: white;
            min-height: 60px;
        }

        .option:hover:not(.disabled) {
            border-color: #f89820;
            background: #fff8f0;
            transform: translateX(5px);
        }

        .option.selected {
            border-color: #f89820;
            background: #fff5e6;
        }

        .option.correct {
            border-color: #28a745;
            background: #d4edda;
        }

        .option.correct .option-text {
            color: #155724 !important;
        }

        .option.incorrect {
            border-color: #dc3545;
            background: #f8d7da;
        }

        .option.incorrect .option-text {
            color: #721c24 !important;
        }

        .option.disabled {
            pointer-events: none;
            opacity: 0.95;
        }

        .option.show-correct {
            border-color: #28a745;
            background: #d4edda;
        }

        .option.show-correct .option-text {
            color: #155724 !important;
        }

        .option-letter {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            min-width: 40px;
            border-radius: 50%;
            background: #f89820;
            color: white;
            font-weight: bold;
            margin-right: 15px;
            flex-shrink: 0;
            font-size: 1rem;
        }

        .option.correct .option-letter {
            background: #28a745;
        }

        .option.incorrect .option-letter {
            background: #dc3545;
        }

        .option.show-correct .option-letter {
            background: #28a745;
        }

        .option-text {
            flex: 1;
            color: #1a1a1a;
            font-size: 1.1rem;
            line-height: 1.5;
            word-wrap: break-word;
            word-break: break-word;
            font-weight: 500;
            display: block;
        }

        .explanation {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-left: 4px solid #f89820;
            border-radius: 0 10px 10px 0;
            display: none;
        }

        .explanation.show {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        .explanation h4 {
            color: #f89820;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .explanation p {
            color: #555;
            line-height: 1.6;
        }

        .btn-container {
            margin-top: 25px;
            display: flex;
            justify-content: flex-end;
            gap: 15px;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .btn-primary {
            background: linear-gradient(135deg, #f89820, #5382a1);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(248, 152, 32, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #545b62;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .results-card {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .results-card.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        .score-circle {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: linear-gradient(135deg, #f89820, #5382a1);
            margin: 0 auto 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            box-shadow: 0 10px 30px rgba(248, 152, 32, 0.3);
        }

        .score-text {
            text-align: center;
        }

        .score-number {
            font-size: 3.5rem;
            font-weight: bold;
        }

        .score-label {
            font-size: 1rem;
            opacity: 0.9;
        }

        .results-message {
            font-size: 1.5rem;
            color: #333;
            margin-bottom: 15px;
        }

        .results-details {
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1rem;
        }

        .results-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .stat-box {
            padding: 20px 30px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-box.correct {
            background: #d4edda;
            color: #155724;
        }

        .stat-box.wrong {
            background: #f8d7da;
            color: #721c24;
        }

        .stat-box.time {
            background: #e7f1ff;
            color: #004085;
        }

        .stat-box .stat-number {
            font-size: 2rem;
            font-weight: bold;
        }

        .stat-box .stat-label {
            font-size: 0.9rem;
        }

        .category-scores {
            text-align: left;
            max-width: 600px;
            margin: 0 auto 30px;
            max-height: 300px;
            overflow-y: auto;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .category-score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #e0e0e0;
            gap: 15px;
        }

        .category-score-item:last-child {
            border-bottom: none;
        }

        .category-name {
            flex: 1;
            font-weight: 500;
        }

        .category-score-value {
            min-width: 80px;
            text-align: right;
            font-weight: bold;
            color: #f89820;
        }

        .category-score-bar {
            width: 100px;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }

        .category-score-fill {
            height: 100%;
            background: linear-gradient(90deg, #f89820, #5382a1);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .start-screen {
            text-align: center;
            padding: 40px;
        }

        .start-screen h2 {
            color: #333;
            margin-bottom: 20px;
        }

        .start-screen p {
            color: #666;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .categories-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 30px;
            text-align: left;
        }

        .category-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            background: #f8f9fa;
            border-radius: 8px;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .category-item:hover {
            background: #fff5e6;
            transform: translateX(5px);
        }

        .category-item::before {
            content: "‚òï";
            color: #f89820;
            font-weight: bold;
            margin-right: 10px;
        }

        .quiz-options {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
        }

        .quiz-options h3 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.2rem;
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .option-group {
            margin-bottom: 0;
        }

        .option-group label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 600;
        }

        .option-group select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            background: white;
            transition: all 0.3s ease;
        }

        .option-group select:focus {
            outline: none;
            border-color: #f89820;
            box-shadow: 0 0 0 3px rgba(248, 152, 32, 0.1);
        }

        .java-logo {
            font-size: 5rem;
            margin-bottom: 20px;
        }

        .btn-container-center {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .resume-banner {
            background: linear-gradient(135deg, #17a2b8, #138496);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 15px;
        }

        .resume-banner .resume-text {
            flex: 1;
        }

        .resume-banner .resume-text strong {
            display: block;
            font-size: 1.1rem;
            margin-bottom: 5px;
        }

        .resume-banner .resume-text span {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .resume-banner .resume-buttons {
            display: flex;
            gap: 10px;
        }

        .resume-banner .btn-resume {
            background: white;
            color: #17a2b8;
            padding: 8px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .resume-banner .btn-resume:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        }

        .resume-banner .btn-dismiss {
            background: transparent;
            color: white;
            border: 2px solid white;
            padding: 8px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .resume-banner .btn-dismiss:hover {
            background: rgba(255,255,255,0.1);
        }

        .quit-btn-container {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            justify-content: center;
        }

        @media (max-width: 600px) {
            .quiz-header h1 {
                font-size: 1.8rem;
            }

            .question-text {
                font-size: 1.1rem;
            }

            .btn-container {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }

            .categories-grid {
                grid-template-columns: 1fr;
            }

            .options-grid {
                grid-template-columns: 1fr;
            }

            .results-stats {
                flex-direction: column;
                align-items: center;
            }

            .option {
                padding: 12px 15px;
            }

            .option-letter {
                width: 36px;
                height: 36px;
                min-width: 36px;
                font-size: 0.9rem;
                margin-right: 12px;
            }

            .option-text {
                font-size: 1rem;
            }

            .time-up-message {
                flex-direction: column;
                text-align: center;
            }

            .resume-banner {
                flex-direction: column;
                text-align: center;
            }

            .resume-banner .resume-buttons {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="quiz-container">
        <div class="quiz-header">
            <h1>‚òï Java Quiz</h1>
            <p>200 Questions across 20 Categories ‚Ä¢ 5 Random Options per Question</p>
        </div>

        <div class="progress-container" id="progressContainer" style="display: none;">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
            <div class="progress-text">
                <span>Question <span id="currentQuestion">1</span> of <span id="totalQuestions">20</span></span>
                <div class="timer-container">
                    <span class="timer-icon">‚è±Ô∏è</span>
                    <span class="timer" id="timer">00:00</span>
                </div>
                <span>‚úÖ <span id="correctCount">0</span> | ‚ùå <span id="wrongCount">0</span> | Score: <span id="currentScore">0</span>%</span>
            </div>
        </div>

        <div class="quiz-content">
            <!-- Start Screen -->
            <div class="start-screen" id="startScreen">
                <div class="java-logo">‚òï</div>
                <h2>Welcome to the Java Quiz!</h2>
                <p>Test your Java knowledge with 200 carefully crafted questions.<br>Each question shows 5 randomly selected options from 7 possible answers!</p>
                
                <!-- Resume Banner (hidden by default) -->
                <div class="resume-banner" id="resumeBanner" style="display: none;">
                    <div class="resume-text">
                        <strong>üìù Resume Previous Quiz?</strong>
                        <span id="resumeInfo">You have an unfinished quiz.</span>
                    </div>
                    <div class="resume-buttons">
                        <button class="btn-resume" onclick="resumeQuiz()">Resume</button>
                        <button class="btn-dismiss" onclick="dismissResume()">Start New</button>
                    </div>
                </div>
                
                <div class="quiz-options">
                    <h3>‚öôÔ∏è Quiz Settings</h3>
                    <div class="options-grid">
                        <div class="option-group">
                            <label for="categorySelect">üìÅ Category:</label>
                            <select id="categorySelect" onchange="saveSettings()">
                                <option value="all">All Categories (Random Mix)</option>
                                <option value="basics">1. Java Basics</option>
                                <option value="oop">2. OOP Concepts</option>
                                <option value="classes">3. Classes & Objects</option>
                                <option value="inheritance">4. Inheritance</option>
                                <option value="interfaces">5. Interfaces & Abstract</option>
                                <option value="exceptions">6. Exception Handling</option>
                                <option value="collections">7. Collections Framework</option>
                                <option value="generics">8. Generics</option>
                                <option value="streams">9. Streams API</option>
                                <option value="lambdas">10. Lambda Expressions</option>
                                <option value="multithreading">11. Multithreading</option>
                                <option value="io">12. I/O & NIO</option>
                                <option value="jdbc">13. JDBC</option>
                                <option value="strings">14. Strings</option>
                                <option value="memory">15. Memory Management</option>
                                <option value="annotations">16. Annotations</option>
                                <option value="reflection">17. Reflection</option>
                                <option value="modules">18. Modules (JPMS)</option>
                                <option value="records">19. Records & Sealed</option>
                                <option value="bestpractices">20. Best Practices</option>
                            </select>
                        </div>
                        <div class="option-group">
                            <label for="difficultySelect">üìä Difficulty:</label>
                            <select id="difficultySelect" onchange="saveSettings()">
                                <option value="all">All Difficulties</option>
                                <option value="easy">Easy Only</option>
                                <option value="medium">Medium Only</option>
                                <option value="hard">Hard Only</option>
                            </select>
                        </div>
                        <div class="option-group">
                            <label for="questionCount">üî¢ Questions:</label>
                            <select id="questionCount" onchange="saveSettings()">
                                <option value="10" selected>10 Questions</option>
                                <option value="20">20 Questions</option>
                                <option value="50">50 Questions</option>
                                <option value="100">100 Questions</option>
                                <option value="200">All 200 Questions</option>
                            </select>
                        </div>
                        <div class="option-group">
                            <label for="timerSelect">‚è±Ô∏è Timer:</label>
                            <select id="timerSelect" onchange="saveSettings()">
                                <option value="0">No Timer</option>
                                <option value="15">15 seconds per question</option>
                                <option value="30" selected>30 seconds per question</option>
                                <option value="45">45 seconds per question</option>
                                <option value="60">60 seconds per question</option>
                            </select>
                        </div>
                    </div>
                </div>

                <h3 style="margin-bottom: 15px; color: #333;">üìö 20 Categories Covered:</h3>
                <div class="categories-grid">
                    <div class="category-item">Java Basics</div>
                    <div class="category-item">OOP Concepts</div>
                    <div class="category-item">Classes & Objects</div>
                    <div class="category-item">Inheritance</div>
                    <div class="category-item">Interfaces & Abstract</div>
                    <div class="category-item">Exception Handling</div>
                    <div class="category-item">Collections Framework</div>
                    <div class="category-item">Generics</div>
                    <div class="category-item">Streams API</div>
                    <div class="category-item">Lambda Expressions</div>
                    <div class="category-item">Multithreading</div>
                    <div class="category-item">I/O & NIO</div>
                    <div class="category-item">JDBC</div>
                    <div class="category-item">Strings</div>
                    <div class="category-item">Memory Management</div>
                    <div class="category-item">Annotations</div>
                    <div class="category-item">Reflection</div>
                    <div class="category-item">Modules (JPMS)</div>
                    <div class="category-item">Records & Sealed</div>
                    <div class="category-item">Best Practices</div>
                </div>

                <button class="btn btn-primary" onclick="startQuiz()" style="padding: 15px 50px; font-size: 1.2rem;">
                    üöÄ Start Quiz
                </button>
            </div>

            <!-- Questions Container -->
            <div id="questionsContainer"></div>

            <!-- Results Screen -->
            <div class="results-card" id="resultsCard">
                <div class="score-circle">
                    <div class="score-text">
                        <div class="score-number" id="finalScore">0%</div>
                        <div class="score-label">Final Score</div>
                    </div>
                </div>
                <div class="results-message" id="resultsMessage"></div>
                <div class="results-details" id="resultsDetails"></div>
                
                <div class="results-stats">
                    <div class="stat-box correct">
                        <div class="stat-number" id="finalCorrect">0</div>
                        <div class="stat-label">Correct Answers</div>
                    </div>
                    <div class="stat-box wrong">
                        <div class="stat-number" id="finalWrong">0</div>
                        <div class="stat-label">Wrong Answers</div>
                    </div>
                    <div class="stat-box time">
                        <div class="stat-number" id="finalTime">00:00</div>
                        <div class="stat-label">Total Time</div>
                    </div>
                </div>
                
                <h3 style="margin-bottom: 15px;">üìä Score by Category:</h3>
                <div class="category-scores" id="categoryScores"></div>
                
                <div class="btn-container-center">
                    <button class="btn btn-primary" onclick="restartQuiz()">üîÑ Try Again</button>
                    <button class="btn btn-secondary" onclick="backToMenu()">üè† Back to Menu</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Complete quiz data - 200 questions across 20 categories (10 each)
        // Each question has 7 options, 5 will be randomly displayed
        const allQuestions = {
            basics: [
                {
                    question: "What is the entry point of a Java application?",
                    options: ["public static void main(String[] args)", "public void main(String[] args)", "static void main(String args)", "public static main(String[] args)", "void main()", "public main(String[] args)", "static public void main()"],
                    correct: 0,
                    explanation: "The main method with signature 'public static void main(String[] args)' is the entry point where JVM starts execution.",
                    difficulty: "easy"
                },
                {
                    question: "Which keyword is used to define a constant in Java?",
                    options: ["final", "const", "static", "constant", "immutable", "readonly", "fixed"],
                    correct: 0,
                    explanation: "The 'final' keyword is used to declare constants. Once assigned, the value cannot be changed.",
                    difficulty: "easy"
                },
                {
                    question: "What is the size of an int in Java?",
                    options: ["32 bits", "16 bits", "64 bits", "8 bits", "Platform dependent", "28 bits", "24 bits"],
                    correct: 0,
                    explanation: "In Java, an int is always 32 bits (4 bytes) regardless of the platform.",
                    difficulty: "easy"
                },
                {
                    question: "Which of these is NOT a primitive data type in Java?",
                    options: ["String", "int", "boolean", "char", "double", "byte", "float"],
                    correct: 0,
                    explanation: "String is a class (reference type), not a primitive. The 8 primitives are: byte, short, int, long, float, double, boolean, char.",
                    difficulty: "easy"
                },
                {
                    question: "What is the default value of a boolean instance variable?",
                    options: ["false", "true", "null", "0", "undefined", "empty", "none"],
                    correct: 0,
                    explanation: "The default value of a boolean instance variable is false.",
                    difficulty: "medium"
                },
                {
                    question: "What does JVM stand for?",
                    options: ["Java Virtual Machine", "Java Variable Method", "Java Verified Module", "Java Version Manager", "Just Virtual Memory", "Java Visual Manager", "Java Vendor Machine"],
                    correct: 0,
                    explanation: "JVM stands for Java Virtual Machine, which executes Java bytecode.",
                    difficulty: "easy"
                },
                {
                    question: "Which operator is used for string concatenation?",
                    options: ["+", "&", ".", "++", "concat", "<<", "||"],
                    correct: 0,
                    explanation: "The + operator is overloaded in Java to perform string concatenation.",
                    difficulty: "easy"
                },
                {
                    question: "What is the result of 10 / 3 in Java (integer division)?",
                    options: ["3", "3.33", "3.0", "4", "3.333333", "Error", "10/3"],
                    correct: 0,
                    explanation: "Integer division truncates the decimal part, so 10/3 equals 3.",
                    difficulty: "medium"
                },
                {
                    question: "Which access modifier makes a member accessible only within its own class?",
                    options: ["private", "protected", "public", "default", "internal", "local", "restricted"],
                    correct: 0,
                    explanation: "The private modifier restricts access to only within the same class.",
                    difficulty: "medium"
                },
                {
                    question: "What is bytecode in Java?",
                    options: ["Intermediate code executed by JVM", "Machine code for CPU", "Source code", "Assembly language", "Binary executable", "Compiled native code", "Script code"],
                    correct: 0,
                    explanation: "Bytecode is platform-independent intermediate code that JVM interprets or JIT-compiles.",
                    difficulty: "hard"
                }
            ],
            oop: [
                {
                    question: "What are the four main principles of OOP?",
                    options: ["Encapsulation, Inheritance, Polymorphism, Abstraction", "Classes, Objects, Methods, Variables", "Public, Private, Protected, Default", "Compile, Run, Debug, Test", "Create, Read, Update, Delete", "Input, Process, Output, Store", "Design, Code, Test, Deploy"],
                    correct: 0,
                    explanation: "The four pillars of OOP are Encapsulation, Inheritance, Polymorphism, and Abstraction.",
                    difficulty: "easy"
                },
                {
                    question: "What is encapsulation?",
                    options: ["Hiding internal details and providing public interface", "Creating multiple classes", "Inheriting from parent class", "Overriding methods", "Creating objects", "Defining interfaces", "Using abstract classes"],
                    correct: 0,
                    explanation: "Encapsulation is bundling data and methods together while hiding internal implementation details.",
                    difficulty: "easy"
                },
                {
                    question: "What is polymorphism?",
                    options: ["Ability of objects to take many forms", "Creating multiple objects", "Hiding data", "Single inheritance", "Method overloading only", "Creating interfaces", "Using final classes"],
                    correct: 0,
                    explanation: "Polymorphism allows objects to be treated as instances of their parent class, enabling method overriding and overloading.",
                    difficulty: "easy"
                },
                {
                    question: "What is the difference between method overloading and overriding?",
                    options: ["Overloading is compile-time, overriding is runtime polymorphism", "They are the same thing", "Overloading requires inheritance", "Overriding changes return type only", "Overloading is runtime polymorphism", "Overriding is compile-time polymorphism", "Neither requires methods"],
                    correct: 0,
                    explanation: "Overloading (same name, different parameters) is resolved at compile-time; overriding (same signature in subclass) is resolved at runtime.",
                    difficulty: "medium"
                },
                {
                    question: "What is abstraction in OOP?",
                    options: ["Showing only essential features and hiding complexity", "Creating abstract classes only", "Using interfaces only", "Hiding all methods", "Making everything private", "Using only static methods", "Avoiding inheritance"],
                    correct: 0,
                    explanation: "Abstraction focuses on what an object does rather than how it does it, hiding implementation complexity.",
                    difficulty: "medium"
                },
                {
                    question: "What is the 'IS-A' relationship in Java?",
                    options: ["Inheritance relationship", "Composition relationship", "Association relationship", "Aggregation relationship", "Dependency relationship", "Implementation relationship", "Delegation relationship"],
                    correct: 0,
                    explanation: "IS-A represents inheritance where a subclass 'is a' type of its superclass.",
                    difficulty: "medium"
                },
                {
                    question: "What is the 'HAS-A' relationship?",
                    options: ["Composition/Aggregation relationship", "Inheritance relationship", "Interface implementation", "Method overriding", "Class extension", "Type casting", "Method overloading"],
                    correct: 0,
                    explanation: "HAS-A represents composition or aggregation where a class contains reference to another class.",
                    difficulty: "medium"
                },
                {
                    question: "What is tight coupling?",
                    options: ["High dependency between classes", "Low dependency between classes", "No relationship between classes", "Using interfaces", "Using abstract classes", "Proper encapsulation", "Good design practice"],
                    correct: 0,
                    explanation: "Tight coupling means classes are highly dependent on each other, making changes difficult.",
                    difficulty: "hard"
                },
                {
                    question: "What is cohesion in OOP?",
                    options: ["Degree to which elements of a module belong together", "Dependency between modules", "Number of classes in a package", "Lines of code in a class", "Number of methods", "Inheritance depth", "Interface count"],
                    correct: 0,
                    explanation: "High cohesion means a class has a single, well-defined purpose with closely related methods.",
                    difficulty: "hard"
                },
                {
                    question: "What design principle states 'Program to an interface, not an implementation'?",
                    options: ["Dependency Inversion Principle", "Single Responsibility Principle", "Open/Closed Principle", "Liskov Substitution", "Interface Segregation", "DRY Principle", "KISS Principle"],
                    correct: 0,
                    explanation: "This is part of the Dependency Inversion Principle, promoting loose coupling through abstractions.",
                    difficulty: "hard"
                }
            ],
            classes: [
                {
                    question: "What keyword is used to create an object in Java?",
                    options: ["new", "create", "object", "instance", "make", "construct", "build"],
                    correct: 0,
                    explanation: "The 'new' keyword allocates memory and creates a new instance of a class.",
                    difficulty: "easy"
                },
                {
                    question: "What is a constructor in Java?",
                    options: ["Special method to initialize objects", "Method to destroy objects", "Static method", "Final method", "Abstract method", "Private method only", "Return type method"],
                    correct: 0,
                    explanation: "A constructor is a special method with the same name as the class, used to initialize new objects.",
                    difficulty: "easy"
                },
                {
                    question: "What is the default constructor?",
                    options: ["No-argument constructor provided by compiler if none defined", "Constructor with all parameters", "Private constructor", "Static constructor", "Final constructor", "Abstract constructor", "Protected constructor"],
                    correct: 0,
                    explanation: "If no constructor is defined, Java provides a default no-argument constructor.",
                    difficulty: "easy"
                },
                {
                    question: "Can a constructor be private?",
                    options: ["Yes, used in Singleton pattern", "No, always public", "Only in abstract classes", "Only in interfaces", "Only in final classes", "Only with static", "Never allowed"],
                    correct: 0,
                    explanation: "Private constructors prevent instantiation from outside, commonly used in Singleton pattern.",
                    difficulty: "medium"
                },
                {
                    question: "What is 'this' keyword used for?",
                    options: ["Reference to current object", "Reference to parent class", "Reference to child class", "Static reference", "Null reference", "Super reference", "Class reference"],
                    correct: 0,
                    explanation: "'this' refers to the current object instance, useful for disambiguation and constructor chaining.",
                    difficulty: "easy"
                },
                {
                    question: "What is constructor chaining?",
                    options: ["Calling one constructor from another using this() or super()", "Creating multiple constructors", "Overloading constructors", "Overriding constructors", "Deleting constructors", "Hiding constructors", "Copying constructors"],
                    correct: 0,
                    explanation: "Constructor chaining uses this() to call another constructor in same class or super() for parent class.",
                    difficulty: "medium"
                },
                {
                    question: "What is a static block?",
                    options: ["Block executed once when class is loaded", "Block executed for each object", "Block inside methods", "Block for exception handling", "Block for loops", "Block for conditions", "Block for synchronization"],
                    correct: 0,
                    explanation: "Static blocks run once when the class is first loaded into memory, before any objects are created.",
                    difficulty: "medium"
                },
                {
                    question: "What is an instance initializer block?",
                    options: ["Block executed before constructor for each object", "Static initialization block", "Method block", "Exception block", "Loop block", "Conditional block", "Synchronized block"],
                    correct: 0,
                    explanation: "Instance initializer blocks run before the constructor each time an object is created.",
                    difficulty: "hard"
                },
                {
                    question: "What is the order of initialization in Java?",
                    options: ["Static blocks, instance blocks, constructor", "Constructor, static blocks, instance blocks", "Instance blocks, static blocks, constructor", "Constructor only", "Static blocks only", "Random order", "Alphabetical order"],
                    correct: 0,
                    explanation: "Order: static blocks (once), then instance blocks and constructor (for each object).",
                    difficulty: "hard"
                },
                {
                    question: "Can a class have multiple constructors?",
                    options: ["Yes, through constructor overloading", "No, only one allowed", "Only two allowed", "Only with inheritance", "Only if abstract", "Only if final", "Only if static"],
                    correct: 0,
                    explanation: "Constructor overloading allows multiple constructors with different parameter lists.",
                    difficulty: "easy"
                }
            ],
            inheritance: [
                {
                    question: "Which keyword is used for inheritance in Java?",
                    options: ["extends", "implements", "inherits", "derives", "super", "base", "parent"],
                    correct: 0,
                    explanation: "The 'extends' keyword is used to inherit from a class.",
                    difficulty: "easy"
                },
                {
                    question: "Does Java support multiple inheritance of classes?",
                    options: ["No, only single inheritance", "Yes, multiple inheritance", "Only through interfaces", "Only abstract classes", "Only final classes", "Depends on JVM", "Only in Java 8+"],
                    correct: 0,
                    explanation: "Java doesn't support multiple class inheritance to avoid the diamond problem, but allows multiple interface implementation.",
                    difficulty: "easy"
                },
                {
                    question: "What does 'super' keyword do?",
                    options: ["References parent class members and constructor", "References current class", "Creates new object", "Destroys object", "References static members", "References private members", "References final members"],
                    correct: 0,
                    explanation: "'super' accesses parent class constructors, methods, and fields.",
                    difficulty: "easy"
                },
                {
                    question: "Can a subclass access private members of superclass?",
                    options: ["No, private members are not inherited", "Yes, always accessible", "Only through reflection", "Only in same package", "Only if final", "Only if static", "Only through super"],
                    correct: 0,
                    explanation: "Private members are not accessible in subclasses; use protected or public for inheritance.",
                    difficulty: "medium"
                },
                {
                    question: "What is method overriding?",
                    options: ["Redefining parent method in child class with same signature", "Creating new method", "Overloading method", "Hiding method", "Deleting method", "Renaming method", "Copying method"],
                    correct: 0,
                    explanation: "Overriding provides a specific implementation of a method already defined in the parent class.",
                    difficulty: "easy"
                },
                {
                    question: "What annotation should be used when overriding?",
                    options: ["@Override", "@Overriding", "@Override()", "@Method", "@Inherit", "@Super", "@Replace"],
                    correct: 0,
                    explanation: "@Override annotation helps catch errors if the method doesn't actually override a parent method.",
                    difficulty: "easy"
                },
                {
                    question: "Can you override a static method?",
                    options: ["No, static methods are hidden, not overridden", "Yes, like instance methods", "Only in interfaces", "Only if public", "Only if final", "Only in abstract classes", "Depends on return type"],
                    correct: 0,
                    explanation: "Static methods belong to the class, not instances, so they are hidden rather than overridden.",
                    difficulty: "medium"
                },
                {
                    question: "What is the diamond problem?",
                    options: ["Ambiguity when inheriting from multiple classes with same method", "Memory leak issue", "Compilation error", "Runtime exception", "Design pattern", "Testing problem", "Performance issue"],
                    correct: 0,
                    explanation: "Diamond problem occurs when a class inherits from two classes that have the same method, causing ambiguity.",
                    difficulty: "hard"
                },
                {
                    question: "Can a final method be overridden?",
                    options: ["No, final methods cannot be overridden", "Yes, always", "Only in same package", "Only if public", "Only in interfaces", "Only in abstract classes", "Depends on class"],
                    correct: 0,
                    explanation: "The final keyword prevents method overriding in subclasses.",
                    difficulty: "medium"
                },
                {
                    question: "What is covariant return type?",
                    options: ["Overriding method can return subtype of original return type", "Must return same type", "Can return any type", "Must return void", "Must return Object", "Cannot change return type", "Must return primitive"],
                    correct: 0,
                    explanation: "Since Java 5, overriding methods can return a subtype of the declared return type.",
                    difficulty: "hard"
                }
            ],
            interfaces: [
                {
                    question: "What keyword is used to implement an interface?",
                    options: ["implements", "extends", "interface", "abstract", "inherit", "use", "apply"],
                    correct: 0,
                    explanation: "The 'implements' keyword is used when a class implements an interface.",
                    difficulty: "easy"
                },
                {
                    question: "Can an interface have method implementations?",
                    options: ["Yes, using default and static methods since Java 8", "No, never", "Only abstract methods", "Only in Java 11+", "Only private methods", "Only public methods", "Only final methods"],
                    correct: 0,
                    explanation: "Since Java 8, interfaces can have default and static methods with implementations.",
                    difficulty: "medium"
                },
                {
                    question: "What is a functional interface?",
                    options: ["Interface with exactly one abstract method", "Interface with no methods", "Interface with only default methods", "Interface with multiple abstract methods", "Interface with static methods only", "Interface with private methods", "Interface with final methods"],
                    correct: 0,
                    explanation: "A functional interface has exactly one abstract method and can be used with lambda expressions.",
                    difficulty: "medium"
                },
                {
                    question: "What is the difference between abstract class and interface?",
                    options: ["Abstract class can have state and constructors, interface cannot", "They are identical", "Interface can have constructors", "Abstract class cannot have methods", "Interface must have implementations", "Abstract class cannot be extended", "Interface cannot be implemented"],
                    correct: 0,
                    explanation: "Abstract classes can have instance variables, constructors, and any access modifiers; interfaces are more restricted.",
                    difficulty: "medium"
                },
                {
                    question: "Can an interface extend another interface?",
                    options: ["Yes, using extends keyword", "No, interfaces cannot extend", "Only using implements", "Only abstract interfaces", "Only functional interfaces", "Only marker interfaces", "Only in Java 8+"],
                    correct: 0,
                    explanation: "Interfaces can extend other interfaces using the extends keyword, even multiple interfaces.",
                    difficulty: "easy"
                },
                {
                    question: "What is a marker interface?",
                    options: ["Interface with no methods, used to mark a class", "Interface with one method", "Interface with default methods", "Interface with static methods", "Interface with abstract methods", "Interface with private methods", "Interface with constants"],
                    correct: 0,
                    explanation: "Marker interfaces like Serializable have no methods but mark classes for special treatment.",
                    difficulty: "medium"
                },
                {
                    question: "What are default methods in interfaces?",
                    options: ["Methods with implementation using 'default' keyword", "Abstract methods", "Static methods", "Private methods", "Final methods", "Protected methods", "Public methods only"],
                    correct: 0,
                    explanation: "Default methods provide implementation in interfaces, allowing backward compatibility.",
                    difficulty: "medium"
                },
                {
                    question: "Can interface have private methods?",
                    options: ["Yes, since Java 9", "No, never", "Only in Java 8", "Only if static", "Only if default", "Only if abstract", "Only if final"],
                    correct: 0,
                    explanation: "Java 9 introduced private methods in interfaces to share code between default methods.",
                    difficulty: "hard"
                },
                {
                    question: "What is the @FunctionalInterface annotation?",
                    options: ["Ensures interface has exactly one abstract method", "Makes interface functional", "Required for all interfaces", "Makes methods abstract", "Enables lambda support", "Required for default methods", "Required for static methods"],
                    correct: 0,
                    explanation: "@FunctionalInterface is optional but helps catch errors if more than one abstract method is added.",
                    difficulty: "medium"
                },
                {
                    question: "Can an abstract class implement an interface without implementing all methods?",
                    options: ["Yes, abstract class can leave methods unimplemented", "No, must implement all", "Only if interface is abstract", "Only if methods are default", "Only if methods are static", "Only in same package", "Only if final"],
                    correct: 0,
                    explanation: "Abstract classes can implement interfaces partially, leaving implementation to concrete subclasses.",
                    difficulty: "hard"
                }
            ],
            exceptions: [
                {
                    question: "What is the parent class of all exceptions in Java?",
                    options: ["Throwable", "Exception", "Error", "RuntimeException", "Object", "ExceptionBase", "BaseException"],
                    correct: 0,
                    explanation: "Throwable is the parent class of both Exception and Error classes.",
                    difficulty: "easy"
                },
                {
                    question: "What is the difference between checked and unchecked exceptions?",
                    options: ["Checked must be handled or declared, unchecked don't", "They are the same", "Unchecked must be handled", "Checked are runtime exceptions", "Unchecked are compile-time", "Checked cannot be caught", "Unchecked cannot be thrown"],
                    correct: 0,
                    explanation: "Checked exceptions must be caught or declared in throws clause; unchecked (RuntimeException) don't require handling.",
                    difficulty: "medium"
                },
                {
                    question: "Which keyword is used to throw an exception?",
                    options: ["throw", "throws", "thrown", "throwing", "exception", "raise", "error"],
                    correct: 0,
                    explanation: "'throw' is used to explicitly throw an exception object.",
                    difficulty: "easy"
                },
                {
                    question: "What is the purpose of 'finally' block?",
                    options: ["Code that always executes regardless of exception", "Catches all exceptions", "Throws exceptions", "Declares exceptions", "Prevents exceptions", "Logs exceptions", "Ignores exceptions"],
                    correct: 0,
                    explanation: "Finally block always executes, used for cleanup like closing resources.",
                    difficulty: "easy"
                },
                {
                    question: "Can we have try without catch?",
                    options: ["Yes, with finally or try-with-resources", "No, catch is required", "Only in Java 7+", "Only with throws", "Only with throw", "Only in main method", "Only in static methods"],
                    correct: 0,
                    explanation: "Try can be used with finally alone or with try-with-resources without explicit catch.",
                    difficulty: "medium"
                },
                {
                    question: "What is try-with-resources?",
                    options: ["Automatic resource management that closes resources", "Try block with multiple catches", "Try block with finally", "Try block with throws", "Try block with throw", "Try block with return", "Try block with break"],
                    correct: 0,
                    explanation: "Try-with-resources automatically closes resources implementing AutoCloseable interface.",
                    difficulty: "medium"
                },
                {
                    question: "What is exception chaining?",
                    options: ["Wrapping one exception in another to preserve cause", "Multiple catch blocks", "Multiple try blocks", "Multiple finally blocks", "Multiple throw statements", "Multiple throws declarations", "Multiple exception types"],
                    correct: 0,
                    explanation: "Exception chaining preserves the original exception as the cause of a new exception.",
                    difficulty: "hard"
                },
                {
                    question: "Can we catch multiple exceptions in single catch block?",
                    options: ["Yes, using multi-catch with | operator since Java 7", "No, one exception per catch", "Only checked exceptions", "Only unchecked exceptions", "Only in Java 8+", "Only RuntimeExceptions", "Only Errors"],
                    correct: 0,
                    explanation: "Multi-catch syntax: catch (IOException | SQLException e) handles multiple exception types.",
                    difficulty: "medium"
                },
                {
                    question: "What happens if exception is thrown in finally block?",
                    options: ["It suppresses any exception from try/catch", "It's ignored", "Compilation error", "Runtime error only", "Both exceptions thrown", "Finally doesn't execute", "Program terminates"],
                    correct: 0,
                    explanation: "An exception in finally block suppresses the original exception unless using try-with-resources.",
                    difficulty: "hard"
                },
                {
                    question: "What is the difference between throw and throws?",
                    options: ["throw raises exception, throws declares it in method signature", "They are the same", "throws raises exception", "throw is for checked only", "throws is for unchecked only", "throw is in method body", "throws is deprecated"],
                    correct: 0,
                    explanation: "'throw' is used to throw an exception; 'throws' declares exceptions a method might throw.",
                    difficulty: "easy"
                }
            ],
            collections: [
                {
                    question: "What is the root interface of the Collection framework?",
                    options: ["Collection", "List", "Set", "Map", "Iterable", "Iterator", "Collections"],
                    correct: 0,
                    explanation: "Collection is the root interface for List, Set, and Queue hierarchies. Map is separate.",
                    difficulty: "easy"
                },
                {
                    question: "What is the difference between ArrayList and LinkedList?",
                    options: ["ArrayList uses array, LinkedList uses doubly-linked list", "They are identical", "LinkedList uses array", "ArrayList uses linked list", "Both use arrays", "Both use linked lists", "ArrayList is synchronized"],
                    correct: 0,
                    explanation: "ArrayList provides O(1) random access; LinkedList provides O(1) insertion/deletion at ends.",
                    difficulty: "medium"
                },
                {
                    question: "Which collection doesn't allow duplicate elements?",
                    options: ["Set", "List", "Queue", "Deque", "ArrayList", "LinkedList", "Vector"],
                    correct: 0,
                    explanation: "Set interface and its implementations (HashSet, TreeSet) don't allow duplicates.",
                    difficulty: "easy"
                },
                {
                    question: "What is the difference between HashMap and TreeMap?",
                    options: ["HashMap is unordered, TreeMap is sorted", "They are identical", "HashMap is sorted", "TreeMap is unordered", "HashMap uses tree", "TreeMap uses hash", "Both are sorted"],
                    correct: 0,
                    explanation: "HashMap provides O(1) operations but no ordering; TreeMap maintains sorted order with O(log n) operations.",
                    difficulty: "medium"
                },
                {
                    question: "What is the difference between HashMap and Hashtable?",
                    options: ["HashMap allows null and is not synchronized, Hashtable opposite", "They are identical", "Hashtable allows null", "HashMap is synchronized", "Hashtable is faster", "HashMap is thread-safe", "Hashtable allows duplicates"],
                    correct: 0,
                    explanation: "HashMap allows one null key and multiple null values, is not synchronized. Hashtable is synchronized, no nulls.",
                    difficulty: "medium"
                },
                {
                    question: "What is ConcurrentHashMap?",
                    options: ["Thread-safe HashMap with better concurrency than Hashtable", "Same as HashMap", "Same as Hashtable", "Non-thread-safe map", "Sorted map", "Linked map", "Weak reference map"],
                    correct: 0,
                    explanation: "ConcurrentHashMap uses segment locking for better concurrent performance than Hashtable.",
                    difficulty: "hard"
                },
                {
                    question: "What is the purpose of Comparable interface?",
                    options: ["Define natural ordering for objects", "Compare collections", "Sort arrays only", "Compare primitives", "Define equality", "Define hash code", "Define toString"],
                    correct: 0,
                    explanation: "Comparable's compareTo() method defines the natural ordering of objects for sorting.",
                    difficulty: "medium"
                },
                {
                    question: "What is the difference between Comparable and Comparator?",
                    options: ["Comparable is in class, Comparator is external", "They are identical", "Comparator is in class", "Comparable is external", "Comparable has compare()", "Comparator has compareTo()", "Both modify the class"],
                    correct: 0,
                    explanation: "Comparable modifies the class (compareTo), Comparator is separate (compare) for custom orderings.",
                    difficulty: "medium"
                },
                {
                    question: "What is fail-fast iterator?",
                    options: ["Throws ConcurrentModificationException if collection modified during iteration", "Ignores modifications", "Allows modifications", "Slow iterator", "Safe iterator", "Lazy iterator", "Parallel iterator"],
                    correct: 0,
                    explanation: "Fail-fast iterators immediately throw exception if the collection is structurally modified during iteration.",
                    difficulty: "hard"
                },
                {
                    question: "What is the time complexity of HashMap get operation?",
                    options: ["O(1) average case", "O(n)", "O(log n)", "O(n¬≤)", "O(n log n)", "O(2^n)", "O(1) worst case"],
                    correct: 0,
                    explanation: "HashMap provides O(1) average case for get/put operations, O(n) worst case with many collisions.",
                    difficulty: "medium"
                }
            ],
            generics: [
                {
                    question: "What is the purpose of generics in Java?",
                    options: ["Type safety and code reusability", "Faster execution", "Smaller bytecode", "Better memory management", "Automatic boxing", "Exception handling", "Thread safety"],
                    correct: 0,
                    explanation: "Generics provide compile-time type safety and eliminate the need for casting.",
                    difficulty: "easy"
                },
                {
                    question: "What does <T> represent in generics?",
                    options: ["A type parameter placeholder", "A specific class", "A primitive type", "An interface", "An annotation", "A method", "A variable"],
                    correct: 0,
                    explanation: "T is a type parameter that will be replaced with an actual type when the generic is used.",
                    difficulty: "easy"
                },
                {
                    question: "What is type erasure?",
                    options: ["Generic type information removed at compile time", "Deleting classes", "Removing methods", "Clearing variables", "Memory cleanup", "Exception removal", "Code optimization"],
                    correct: 0,
                    explanation: "Type erasure removes generic type information during compilation for backward compatibility.",
                    difficulty: "medium"
                },
                {
                    question: "What is a bounded type parameter?",
                    options: ["Type parameter with upper or lower bounds", "Unlimited type", "Primitive type", "Final type", "Static type", "Abstract type", "Interface type"],
                    correct: 0,
                    explanation: "Bounded types restrict type parameters: <T extends Number> limits T to Number and subclasses.",
                    difficulty: "medium"
                },
                {
                    question: "What does <?> wildcard mean?",
                    options: ["Unknown type (unbounded wildcard)", "Any primitive", "Null type", "Object type", "Void type", "Error type", "Empty type"],
                    correct: 0,
                    explanation: "The unbounded wildcard <?> represents an unknown type, useful for read-only operations.",
                    difficulty: "medium"
                },
                {
                    question: "What is <? extends T>?",
                    options: ["Upper bounded wildcard - T or its subtypes", "Lower bounded wildcard", "Exact type T", "Any type", "No type", "Multiple types", "Primitive type"],
                    correct: 0,
                    explanation: "Upper bounded wildcard accepts T or any subtype of T, useful for reading.",
                    difficulty: "medium"
                },
                {
                    question: "What is <? super T>?",
                    options: ["Lower bounded wildcard - T or its supertypes", "Upper bounded wildcard", "Exact type T", "Any type", "No type", "Multiple types", "Primitive type"],
                    correct: 0,
                    explanation: "Lower bounded wildcard accepts T or any supertype of T, useful for writing.",
                    difficulty: "hard"
                },
                {
                    question: "Can you create an array of generic type?",
                    options: ["No, due to type erasure", "Yes, always", "Only with wildcards", "Only with bounds", "Only primitives", "Only objects", "Only interfaces"],
                    correct: 0,
                    explanation: "Generic array creation is not allowed because type information is erased at runtime.",
                    difficulty: "hard"
                },
                {
                    question: "What is PECS principle?",
                    options: ["Producer Extends, Consumer Super", "Private Extends, Class Super", "Public Extends, Constant Super", "Parameter Extends, Constructor Super", "Protected Extends, Collection Super", "Package Extends, Component Super", "Primitive Extends, Cast Super"],
                    correct: 0,
                    explanation: "PECS: Use extends when you only get values (producer), super when you only put values (consumer).",
                    difficulty: "hard"
                },
                {
                    question: "Can primitive types be used as type parameters?",
                    options: ["No, only reference types", "Yes, all types", "Only int and long", "Only with autoboxing", "Only in Java 8+", "Only with arrays", "Only with collections"],
                    correct: 0,
                    explanation: "Generics only work with reference types; use wrapper classes (Integer, Double) for primitives.",
                    difficulty: "easy"
                }
            ],
            streams: [
                {
                    question: "What is a Stream in Java?",
                    options: ["Sequence of elements supporting functional operations", "File input/output", "Network connection", "Thread pool", "Memory buffer", "Database connection", "Socket connection"],
                    correct: 0,
                    explanation: "Streams provide a functional approach to processing collections of objects.",
                    difficulty: "easy"
                },
                {
                    question: "What is the difference between intermediate and terminal operations?",
                    options: ["Intermediate returns Stream, terminal produces result", "They are the same", "Terminal returns Stream", "Intermediate produces result", "Both return Stream", "Both produce result", "Neither returns anything"],
                    correct: 0,
                    explanation: "Intermediate operations are lazy and return streams; terminal operations trigger processing and return results.",
                    difficulty: "medium"
                },
                {
                    question: "Which is an intermediate operation?",
                    options: ["filter()", "collect()", "forEach()", "count()", "reduce()", "findFirst()", "anyMatch()"],
                    correct: 0,
                    explanation: "filter(), map(), sorted(), distinct() are intermediate operations returning new streams.",
                    difficulty: "easy"
                },
                {
                    question: "Which is a terminal operation?",
                    options: ["collect()", "filter()", "map()", "sorted()", "distinct()", "limit()", "skip()"],
                    correct: 0,
                    explanation: "collect(), forEach(), reduce(), count(), findFirst() are terminal operations.",
                    difficulty: "easy"
                },
                {
                    question: "What does map() operation do?",
                    options: ["Transforms each element using a function", "Filters elements", "Sorts elements", "Groups elements", "Counts elements", "Removes duplicates", "Limits elements"],
                    correct: 0,
                    explanation: "map() applies a function to each element, transforming the stream.",
                    difficulty: "easy"
                },
                {
                    question: "What does flatMap() do?",
                    options: ["Flattens nested structures into single stream", "Creates nested streams", "Maps to single value", "Filters nested elements", "Sorts nested elements", "Groups nested elements", "Counts nested elements"],
                    correct: 0,
                    explanation: "flatMap() flattens Stream<Stream<T>> into Stream<T>, useful for nested collections.",
                    difficulty: "medium"
                },
                {
                    question: "What is the purpose of Collectors class?",
                    options: ["Provides implementations for collect() operation", "Creates streams", "Filters streams", "Maps streams", "Sorts streams", "Limits streams", "Skips elements"],
                    correct: 0,
                    explanation: "Collectors provides toList(), toSet(), groupingBy(), joining() and other collection operations.",
                    difficulty: "medium"
                },
                {
                    question: "What is a parallel stream?",
                    options: ["Stream that processes elements concurrently", "Sequential stream", "Sorted stream", "Filtered stream", "Mapped stream", "Limited stream", "Distinct stream"],
                    correct: 0,
                    explanation: "Parallel streams use multiple threads to process elements concurrently for better performance.",
                    difficulty: "medium"
                },
                {
                    question: "Can a stream be reused after terminal operation?",
                    options: ["No, streams can only be consumed once", "Yes, always", "Only parallel streams", "Only sequential streams", "Only with reset()", "Only with reuse()", "Only infinite streams"],
                    correct: 0,
                    explanation: "Streams are consumed after terminal operation; create a new stream for reprocessing.",
                    difficulty: "medium"
                },
                {
                    question: "What is Optional in Java?",
                    options: ["Container that may or may not contain a value", "Nullable type", "Exception type", "Collection type", "Stream type", "Primitive type", "Generic type"],
                    correct: 0,
                    explanation: "Optional is a container object used to represent presence or absence of a value, avoiding null.",
                    difficulty: "medium"
                }
            ],
            lambdas: [
                {
                    question: "What is a lambda expression?",
                    options: ["Anonymous function implementing functional interface", "Named function", "Class definition", "Interface definition", "Exception handler", "Thread definition", "Variable declaration"],
                    correct: 0,
                    explanation: "Lambda expressions provide concise syntax for implementing functional interfaces.",
                    difficulty: "easy"
                },
                {
                    question: "What is the syntax of a lambda expression?",
                    options: ["(parameters) -> expression/block", "parameters => expression", "function(parameters)", "lambda(parameters)", "[parameters] -> expression", "{parameters} -> expression", "<parameters> -> expression"],
                    correct: 0,
                    explanation: "Lambda syntax: (params) -> expression or (params) -> { statements; }",
                    difficulty: "easy"
                },
                {
                    question: "Can lambda expressions access local variables?",
                    options: ["Yes, if they are effectively final", "No, never", "Only static variables", "Only instance variables", "Only global variables", "Only public variables", "Only private variables"],
                    correct: 0,
                    explanation: "Lambdas can access local variables that are effectively final (not modified after initialization).",
                    difficulty: "medium"
                },
                {
                    question: "What is a method reference?",
                    options: ["Shorthand for lambda calling existing method", "Creating new method", "Deleting method", "Overriding method", "Overloading method", "Abstract method", "Static method"],
                    correct: 0,
                    explanation: "Method references (Class::method) are shorthand for lambdas that just call an existing method.",
                    difficulty: "medium"
                },
                {
                    question: "What is the Predicate functional interface?",
                    options: ["Takes argument and returns boolean", "Takes no argument", "Returns void", "Takes two arguments", "Returns String", "Returns int", "Returns Object"],
                    correct: 0,
                    explanation: "Predicate<T> has test(T t) method returning boolean, used for filtering.",
                    difficulty: "medium"
                },
                {
                    question: "What is the Function functional interface?",
                    options: ["Takes argument and returns result of different type", "Returns void", "Takes no argument", "Returns boolean", "Returns same type", "Takes multiple arguments", "Returns collection"],
                    correct: 0,
                    explanation: "Function<T,R> has apply(T t) returning R, used for transformations.",
                    difficulty: "medium"
                },
                {
                    question: "What is the Consumer functional interface?",
                    options: ["Takes argument and returns void", "Returns value", "Takes no argument", "Returns boolean", "Takes two arguments", "Returns collection", "Returns Optional"],
                    correct: 0,
                    explanation: "Consumer<T> has accept(T t) returning void, used for side effects.",
                    difficulty: "medium"
                },
                {
                    question: "What is the Supplier functional interface?",
                    options: ["Takes no argument and returns value", "Takes argument", "Returns void", "Returns boolean", "Takes multiple arguments", "Returns collection", "Returns stream"],
                    correct: 0,
                    explanation: "Supplier<T> has get() returning T with no parameters, used for lazy evaluation.",
                    difficulty: "medium"
                },
                {
                    question: "What is the difference between Runnable and Callable?",
                    options: ["Callable returns value and can throw checked exceptions", "They are identical", "Runnable returns value", "Callable returns void", "Runnable throws exceptions", "Callable is older", "Runnable is newer"],
                    correct: 0,
                    explanation: "Runnable.run() returns void; Callable.call() returns value and can throw checked exceptions.",
                    difficulty: "hard"
                },
                {
                    question: "What types of method references exist?",
                    options: ["Static, instance, constructor references", "Only static", "Only instance", "Only constructor", "Only abstract", "Only final", "Only public"],
                    correct: 0,
                    explanation: "Four types: static (Class::staticMethod), instance (obj::method), arbitrary object (Class::method), constructor (Class::new).",
                    difficulty: "hard"
                }
            ],
            multithreading: [
                {
                    question: "What are the two ways to create a thread in Java?",
                    options: ["Extend Thread class or implement Runnable", "Only extend Thread", "Only implement Runnable", "Use Thread.create()", "Use new Thread()", "Implement Callable only", "Extend Runnable"],
                    correct: 0,
                    explanation: "Threads can be created by extending Thread class or implementing Runnable interface.",
                    difficulty: "easy"
                },
                {
                    question: "What is the purpose of synchronized keyword?",
                    options: ["Ensure only one thread accesses code at a time", "Speed up execution", "Create new threads", "Stop threads", "Pause threads", "Resume threads", "Kill threads"],
                    correct: 0,
                    explanation: "synchronized provides mutual exclusion, preventing race conditions in concurrent code.",
                    difficulty: "easy"
                },
                {
                    question: "What is a deadlock?",
                    options: ["Two or more threads waiting for each other indefinitely", "Thread termination", "Thread creation", "Thread sleeping", "Thread running", "Thread starting", "Thread joining"],
                    correct: 0,
                    explanation: "Deadlock occurs when threads hold locks and wait for locks held by each other.",
                    difficulty: "medium"
                },
                {
                    question: "What does volatile keyword do?",
                    options: ["Ensures visibility of changes across threads", "Makes variable constant", "Speeds up access", "Creates thread-local copy", "Prevents modification", "Enables caching", "Disables synchronization"],
                    correct: 0,
                    explanation: "volatile ensures that reads and writes go directly to main memory, visible to all threads.",
                    difficulty: "medium"
                },
                {
                    question: "What is the difference between wait() and sleep()?",
                    options: ["wait() releases lock, sleep() doesn't", "They are identical", "sleep() releases lock", "wait() doesn't release lock", "wait() is static", "sleep() is instance method", "wait() takes no parameters"],
                    correct: 0,
                    explanation: "wait() releases the monitor lock and must be called from synchronized context; sleep() keeps the lock.",
                    difficulty: "medium"
                },
                {
                    question: "What is a thread pool?",
                    options: ["Collection of reusable threads for executing tasks", "Single thread", "Thread array", "Thread list", "Thread queue", "Thread stack", "Thread set"],
                    correct: 0,
                    explanation: "Thread pools manage a collection of worker threads, reducing overhead of thread creation.",
                    difficulty: "medium"
                },
                {
                    question: "What is ExecutorService?",
                    options: ["Framework for managing thread pools and task execution", "Single thread executor", "Thread factory", "Thread group", "Thread local", "Thread monitor", "Thread scheduler"],
                    correct: 0,
                    explanation: "ExecutorService provides methods to manage termination and produce Futures for tracking tasks.",
                    difficulty: "medium"
                },
                {
                    question: "What is a Future in Java?",
                    options: ["Represents result of asynchronous computation", "Past computation", "Current computation", "Cancelled computation", "Failed computation", "Pending computation", "Completed computation"],
                    correct: 0,
                    explanation: "Future represents the result of an async operation, providing methods to check completion and get result.",
                    difficulty: "medium"
                },
                {
                    question: "What is CompletableFuture?",
                    options: ["Future that can be explicitly completed and composed", "Simple Future", "Cancelled Future", "Failed Future", "Pending Future", "Blocking Future", "Synchronous Future"],
                    correct: 0,
                    explanation: "CompletableFuture supports functional composition and explicit completion of async operations.",
                    difficulty: "hard"
                },
                {
                    question: "What is the difference between Callable and Runnable?",
                    options: ["Callable returns result and throws checked exceptions", "They are identical", "Runnable returns result", "Callable returns void", "Runnable throws checked exceptions", "Callable is older", "Runnable is newer"],
                    correct: 0,
                    explanation: "Callable<V> returns a value and can throw checked exceptions; Runnable returns void.",
                    difficulty: "medium"
                }
            ],
            io: [
                {
                    question: "What is the difference between byte streams and character streams?",
                    options: ["Byte streams handle raw bytes, character streams handle text", "They are identical", "Character streams handle bytes", "Byte streams handle text", "Byte streams are faster", "Character streams are older", "Byte streams support Unicode"],
                    correct: 0,
                    explanation: "Byte streams (InputStream/OutputStream) handle raw bytes; character streams (Reader/Writer) handle Unicode text.",
                    difficulty: "easy"
                },
                {
                    question: "What is BufferedReader used for?",
                    options: ["Efficient reading of text with buffering", "Writing text", "Binary reading", "Network I/O", "Database I/O", "Console output", "File deletion"],
                    correct: 0,
                    explanation: "BufferedReader provides efficient reading by buffering characters, reducing I/O operations.",
                    difficulty: "easy"
                },
                {
                    question: "What is the purpose of try-with-resources?",
                    options: ["Automatic resource management and closing", "Exception handling only", "Thread management", "Memory management", "File creation", "Network connection", "Database connection"],
                    correct: 0,
                    explanation: "Try-with-resources automatically closes resources implementing AutoCloseable.",
                    difficulty: "easy"
                },
                {
                    question: "What is NIO in Java?",
                    options: ["New I/O with channels and buffers for non-blocking I/O", "Network I/O only", "Numeric I/O", "Native I/O", "Null I/O", "Normal I/O", "New Input Only"],
                    correct: 0,
                    explanation: "NIO provides channels, buffers, and selectors for scalable, non-blocking I/O operations.",
                    difficulty: "medium"
                },
                {
                    question: "What is a Channel in NIO?",
                    options: ["Bidirectional connection for I/O operations", "Unidirectional stream", "Memory buffer", "File handle", "Network socket only", "Database connection", "Thread pool"],
                    correct: 0,
                    explanation: "Channels are bidirectional, can be non-blocking, and work with Buffers for I/O.",
                    difficulty: "medium"
                },
                {
                    question: "What is a Buffer in NIO?",
                    options: ["Container for data with position, limit, capacity", "Simple array", "Stream wrapper", "Channel wrapper", "File wrapper", "Network wrapper", "Memory wrapper"],
                    correct: 0,
                    explanation: "Buffers are containers with position, limit, and capacity for reading/writing data.",
                    difficulty: "medium"
                },
                {
                    question: "What is Path in NIO.2?",
                    options: ["Represents file system path", "Network path only", "URL only", "Database path", "Memory path", "Thread path", "Process path"],
                    correct: 0,
                    explanation: "Path represents a file system path and provides methods for path manipulation.",
                    difficulty: "medium"
                },
                {
                    question: "What is Files class used for?",
                    options: ["Static methods for file operations", "Creating File objects", "Stream operations", "Network operations", "Database operations", "Memory operations", "Thread operations"],
                    correct: 0,
                    explanation: "Files class provides static methods for common file operations like copy, move, delete, read.",
                    difficulty: "medium"
                },
                {
                    question: "What is serialization in Java?",
                    options: ["Converting object to byte stream", "Converting bytes to object", "File compression", "Data encryption", "Network transfer", "Memory allocation", "Thread synchronization"],
                    correct: 0,
                    explanation: "Serialization converts an object's state to a byte stream for storage or transmission.",
                    difficulty: "medium"
                },
                {
                    question: "What interface must a class implement to be serializable?",
                    options: ["Serializable", "Externalizable only", "Cloneable", "Comparable", "Iterable", "AutoCloseable", "Readable"],
                    correct: 0,
                    explanation: "Classes must implement Serializable (marker interface) to be serialized.",
                    difficulty: "easy"
                }
            ],
            jdbc: [
                {
                    question: "What does JDBC stand for?",
                    options: ["Java Database Connectivity", "Java Data Base Connection", "Java DB Connector", "Java Database Controller", "Java Data Bridge Connection", "Java DB Communication", "Java Database Component"],
                    correct: 0,
                    explanation: "JDBC (Java Database Connectivity) is the standard API for database access in Java.",
                    difficulty: "easy"
                },
                {
                    question: "What is a JDBC Driver?",
                    options: ["Implementation that connects Java to specific database", "Database server", "SQL parser", "Connection pool", "Query optimizer", "Transaction manager", "Schema manager"],
                    correct: 0,
                    explanation: "JDBC drivers implement the JDBC interfaces for specific database systems.",
                    difficulty: "easy"
                },
                {
                    question: "What is the purpose of DriverManager?",
                    options: ["Manages JDBC drivers and creates connections", "Executes queries", "Manages transactions", "Handles results", "Creates statements", "Manages pools", "Handles errors"],
                    correct: 0,
                    explanation: "DriverManager manages registered drivers and establishes database connections.",
                    difficulty: "easy"
                },
                {
                    question: "What is a PreparedStatement?",
                    options: ["Precompiled SQL statement with parameters", "Simple SQL statement", "Stored procedure call", "Batch statement", "Dynamic statement", "Cached statement", "Pooled statement"],
                    correct: 0,
                    explanation: "PreparedStatement is precompiled, supports parameters, and prevents SQL injection.",
                    difficulty: "medium"
                },
                {
                    question: "What is the advantage of PreparedStatement over Statement?",
                    options: ["Prevents SQL injection and better performance", "Simpler syntax", "No advantages", "Slower execution", "More memory usage", "Less secure", "No parameters"],
                    correct: 0,
                    explanation: "PreparedStatement prevents SQL injection, is precompiled for better performance, and supports parameters.",
                    difficulty: "medium"
                },
                {
                    question: "What is a ResultSet?",
                    options: ["Table of data returned by query execution", "SQL statement", "Database connection", "Transaction object", "Driver object", "Pool object", "Schema object"],
                    correct: 0,
                    explanation: "ResultSet represents the result of a query, providing methods to iterate through rows.",
                    difficulty: "easy"
                },
                {
                    question: "What is connection pooling?",
                    options: ["Reusing database connections for better performance", "Creating new connections", "Closing connections", "Validating connections", "Encrypting connections", "Compressing connections", "Caching queries"],
                    correct: 0,
                    explanation: "Connection pooling maintains a cache of connections for reuse, reducing connection overhead.",
                    difficulty: "medium"
                },
                {
                    question: "What is a transaction in JDBC?",
                    options: ["Unit of work that is atomic, consistent, isolated, durable", "Single query", "Connection", "Statement", "ResultSet", "Driver", "Pool"],
                    correct: 0,
                    explanation: "Transactions group operations that must all succeed or all fail (ACID properties).",
                    difficulty: "medium"
                },
                {
                    question: "How do you start a transaction in JDBC?",
                    options: ["connection.setAutoCommit(false)", "connection.beginTransaction()", "connection.startTransaction()", "connection.openTransaction()", "connection.createTransaction()", "connection.initTransaction()", "connection.newTransaction()"],
                    correct: 0,
                    explanation: "Setting autoCommit to false starts manual transaction management.",
                    difficulty: "medium"
                },
                {
                    question: "What is batch processing in JDBC?",
                    options: ["Executing multiple statements as a group", "Single statement execution", "Parallel execution", "Async execution", "Cached execution", "Pooled execution", "Streamed execution"],
                    correct: 0,
                    explanation: "Batch processing groups multiple SQL statements for efficient execution.",
                    difficulty: "hard"
                }
            ],
            strings: [
                {
                    question: "Are Strings immutable in Java?",
                    options: ["Yes, String objects cannot be changed", "No, Strings are mutable", "Only in some cases", "Depends on JVM", "Only final Strings", "Only static Strings", "Only constant Strings"],
                    correct: 0,
                    explanation: "String objects are immutable; any modification creates a new String object.",
                    difficulty: "easy"
                },
                {
                    question: "What is the String Pool?",
                    options: ["Cache of String literals in heap memory", "Collection of String methods", "String buffer", "String builder", "String array", "String list", "String set"],
                    correct: 0,
                    explanation: "String Pool stores String literals to save memory by reusing identical strings.",
                    difficulty: "medium"
                },
                {
                    question: "What is the difference between == and equals() for Strings?",
                    options: ["== compares references, equals() compares content", "They are identical", "equals() compares references", "== compares content", "== is faster", "equals() is deprecated", "== works for content"],
                    correct: 0,
                    explanation: "== checks if references point to same object; equals() compares actual string content.",
                    difficulty: "easy"
                },
                {
                    question: "What is StringBuilder?",
                    options: ["Mutable sequence of characters, not thread-safe", "Immutable String", "Thread-safe builder", "String constant", "String literal", "String pool", "String cache"],
                    correct: 0,
                    explanation: "StringBuilder is mutable and faster than StringBuffer but not thread-safe.",
                    difficulty: "easy"
                },
                {
                    question: "What is the difference between StringBuilder and StringBuffer?",
                    options: ["StringBuffer is synchronized, StringBuilder is not", "They are identical", "StringBuilder is synchronized", "StringBuffer is faster", "StringBuilder is older", "StringBuffer is deprecated", "StringBuilder is immutable"],
                    correct: 0,
                    explanation: "StringBuffer is thread-safe (synchronized); StringBuilder is faster but not thread-safe.",
                    difficulty: "medium"
                },
                {
                    question: "What does intern() method do?",
                    options: ["Returns canonical representation from String Pool", "Creates new String", "Converts to uppercase", "Converts to lowercase", "Trims whitespace", "Reverses String", "Splits String"],
                    correct: 0,
                    explanation: "intern() returns a String from the pool, or adds it if not present.",
                    difficulty: "hard"
                },
                {
                    question: "How do you compare Strings ignoring case?",
                    options: ["equalsIgnoreCase()", "equals()", "compareTo()", "==", "compareIgnoreCase()", "matchIgnoreCase()", "sameIgnoreCase()"],
                    correct: 0,
                    explanation: "equalsIgnoreCase() compares string content ignoring uppercase/lowercase differences.",
                    difficulty: "easy"
                },
                {
                    question: "What is the result of \"Hello\".substring(1, 3)?",
                    options: ["\"el\"", "\"ell\"", "\"Hel\"", "\"llo\"", "\"He\"", "\"lo\"", "\"l\""],
                    correct: 0,
                    explanation: "substring(1, 3) returns characters from index 1 to 2 (exclusive end): \"el\".",
                    difficulty: "medium"
                },
                {
                    question: "What is a text block in Java?",
                    options: ["Multi-line string literal using triple quotes", "Single line string", "Character array", "Byte array", "String array", "String list", "String buffer"],
                    correct: 0,
                    explanation: "Text blocks (Java 15+) use \"\"\" for multi-line strings with preserved formatting.",
                    difficulty: "medium"
                },
                {
                    question: "What method splits a String by delimiter?",
                    options: ["split()", "divide()", "separate()", "partition()", "break()", "cut()", "slice()"],
                    correct: 0,
                    explanation: "split() divides a string around matches of a regular expression delimiter.",
                    difficulty: "easy"
                }
            ],
            memory: [
                {
                    question: "What is the Java Heap?",
                    options: ["Memory area for object allocation", "Method storage", "Thread storage", "Class storage", "Static storage", "Stack storage", "Native storage"],
                    correct: 0,
                    explanation: "The heap is the runtime data area where objects are allocated by the JVM.",
                    difficulty: "easy"
                },
                {
                    question: "What is the Stack in Java memory?",
                    options: ["Memory for method calls and local variables", "Object storage", "Class storage", "Static storage", "Heap storage", "Native storage", "Permanent storage"],
                    correct: 0,
                    explanation: "Each thread has its own stack storing method frames with local variables and partial results.",
                    difficulty: "easy"
                },
                {
                    question: "What is Garbage Collection?",
                    options: ["Automatic memory management reclaiming unused objects", "Manual memory cleanup", "Memory allocation", "Memory compression", "Memory encryption", "Memory caching", "Memory pooling"],
                    correct: 0,
                    explanation: "GC automatically identifies and removes objects no longer referenced by the program.",
                    difficulty: "easy"
                },
                {
                    question: "What is the purpose of finalize() method?",
                    options: ["Called by GC before object is collected (deprecated)", "Creates objects", "Destroys objects immediately", "Allocates memory", "Frees memory immediately", "Compacts memory", "Validates objects"],
                    correct: 0,
                    explanation: "finalize() was called before GC but is deprecated; use try-with-resources or Cleaner instead.",
                    difficulty: "medium"
                },
                {
                    question: "What are the generations in Java heap?",
                    options: ["Young Generation, Old Generation, (Metaspace)", "Only one generation", "Three equal parts", "Stack and Heap", "Static and Dynamic", "Local and Global", "Temporary and Permanent"],
                    correct: 0,
                    explanation: "Heap is divided into Young (Eden, Survivor) and Old generations for efficient GC.",
                    difficulty: "medium"
                },
                {
                    question: "What is a memory leak in Java?",
                    options: ["Objects retained in memory but no longer needed", "Memory corruption", "Stack overflow", "Heap overflow", "GC failure", "Memory fragmentation", "Memory exhaustion"],
                    correct: 0,
                    explanation: "Memory leaks occur when objects are unintentionally kept referenced, preventing GC.",
                    difficulty: "medium"
                },
                {
                    question: "What is the Metaspace?",
                    options: ["Memory for class metadata (replaced PermGen)", "Object storage", "Stack storage", "Heap storage", "Native storage", "Thread storage", "Method storage"],
                    correct: 0,
                    explanation: "Metaspace (Java 8+) stores class metadata in native memory, replacing PermGen.",
                    difficulty: "hard"
                },
                {
                    question: "What is a soft reference?",
                    options: ["Reference cleared by GC when memory is low", "Strong reference", "Weak reference", "Phantom reference", "Final reference", "Static reference", "Local reference"],
                    correct: 0,
                    explanation: "Soft references are cleared when JVM needs memory, useful for caches.",
                    difficulty: "hard"
                },
                {
                    question: "What is a weak reference?",
                    options: ["Reference that doesn't prevent GC collection", "Strong reference", "Soft reference", "Phantom reference", "Final reference", "Static reference", "Local reference"],
                    correct: 0,
                    explanation: "Weak references don't prevent garbage collection of the referenced object.",
                    difficulty: "hard"
                },
                {
                    question: "How can you request garbage collection?",
                    options: ["System.gc() - but it's only a suggestion", "gc.run()", "Runtime.collect()", "Memory.free()", "Heap.clean()", "JVM.gc()", "Object.gc()"],
                    correct: 0,
                    explanation: "System.gc() suggests GC to JVM, but doesn't guarantee immediate execution.",
                    difficulty: "medium"
                }
            ],
            annotations: [
                {
                    question: "What is an annotation in Java?",
                    options: ["Metadata about program elements", "Comment type", "Documentation", "Exception type", "Interface type", "Class type", "Method type"],
                    correct: 0,
                    explanation: "Annotations provide metadata that can be processed at compile-time or runtime.",
                    difficulty: "easy"
                },
                {
                    question: "What does @Override annotation do?",
                    options: ["Indicates method overrides superclass method", "Creates new method", "Deletes method", "Hides method", "Renames method", "Copies method", "Moves method"],
                    correct: 0,
                    explanation: "@Override helps catch errors by ensuring the method actually overrides a parent method.",
                    difficulty: "easy"
                },
                {
                    question: "What does @Deprecated annotation indicate?",
                    options: ["Element should no longer be used", "Element is new", "Element is required", "Element is optional", "Element is final", "Element is static", "Element is abstract"],
                    correct: 0,
                    explanation: "@Deprecated marks elements that are obsolete and may be removed in future versions.",
                    difficulty: "easy"
                },
                {
                    question: "What does @SuppressWarnings do?",
                    options: ["Tells compiler to ignore specific warnings", "Creates warnings", "Logs warnings", "Throws warnings", "Counts warnings", "Displays warnings", "Stores warnings"],
                    correct: 0,
                    explanation: "@SuppressWarnings instructs the compiler to suppress specified warning types.",
                    difficulty: "easy"
                },
                {
                    question: "What is @FunctionalInterface?",
                    options: ["Indicates interface has exactly one abstract method", "Creates functional interface", "Deletes interface", "Hides interface", "Copies interface", "Moves interface", "Renames interface"],
                    correct: 0,
                    explanation: "@FunctionalInterface ensures the interface can be used with lambda expressions.",
                    difficulty: "medium"
                },
                {
                    question: "What is a meta-annotation?",
                    options: ["Annotation that annotates other annotations", "Regular annotation", "Class annotation", "Method annotation", "Field annotation", "Parameter annotation", "Package annotation"],
                    correct: 0,
                    explanation: "Meta-annotations like @Retention, @Target define how other annotations behave.",
                    difficulty: "medium"
                },
                {
                    question: "What does @Retention specify?",
                    options: ["How long annotation is retained", "Where annotation can be used", "Who can use annotation", "When annotation runs", "Why annotation exists", "What annotation does", "Which annotation to use"],
                    correct: 0,
                    explanation: "@Retention specifies whether annotation is available at SOURCE, CLASS, or RUNTIME.",
                    difficulty: "medium"
                },
                {
                    question: "What does @Target specify?",
                    options: ["Where annotation can be applied", "How long annotation lasts", "Who uses annotation", "When annotation runs", "Why annotation exists", "What annotation does", "Which annotation to use"],
                    correct: 0,
                    explanation: "@Target specifies element types (METHOD, FIELD, CLASS, etc.) where annotation can be used.",
                    difficulty: "medium"
                },
                {
                    question: "How do you create a custom annotation?",
                    options: ["Using @interface keyword", "Using interface keyword", "Using class keyword", "Using annotation keyword", "Using custom keyword", "Using define keyword", "Using create keyword"],
                    correct: 0,
                    explanation: "Custom annotations are defined using @interface followed by the annotation name.",
                    difficulty: "medium"
                },
                {
                    question: "What is @Inherited annotation?",
                    options: ["Makes annotation inherited by subclasses", "Prevents inheritance", "Creates inheritance", "Deletes inheritance", "Hides inheritance", "Copies inheritance", "Moves inheritance"],
                    correct: 0,
                    explanation: "@Inherited causes the annotation to be automatically inherited by subclasses.",
                    difficulty: "hard"
                }
            ],
            reflection: [
                {
                    question: "What is Reflection in Java?",
                    options: ["Ability to examine and modify runtime behavior", "Compile-time analysis", "Static analysis", "Code generation", "Code optimization", "Code compression", "Code encryption"],
                    correct: 0,
                    explanation: "Reflection allows inspection and manipulation of classes, methods, and fields at runtime.",
                    difficulty: "easy"
                },
                {
                    question: "How do you get the Class object of a class?",
                    options: ["ClassName.class or object.getClass()", "new Class()", "Class.create()", "getClass(ClassName)", "Class.of()", "Class.get()", "Class.find()"],
                    correct: 0,
                    explanation: "Use ClassName.class for compile-time or object.getClass() for runtime Class object.",
                    difficulty: "easy"
                },
                {
                    question: "What is Class.forName() used for?",
                    options: ["Load class dynamically by name", "Create class", "Delete class", "Rename class", "Copy class", "Move class", "Hide class"],
                    correct: 0,
                    explanation: "Class.forName() loads a class dynamically using its fully qualified name.",
                    difficulty: "medium"
                },
                {
                    question: "How do you create an instance using reflection?",
                    options: ["class.getDeclaredConstructor().newInstance()", "new class()", "class.create()", "class.build()", "class.make()", "class.construct()", "class.instantiate()"],
                    correct: 0,
                    explanation: "Use getDeclaredConstructor().newInstance() to create objects reflectively.",
                    difficulty: "medium"
                },
                {
                    question: "How do you access private fields using reflection?",
                    options: ["field.setAccessible(true)", "field.makePublic()", "field.unlock()", "field.open()", "field.expose()", "field.reveal()", "field.show()"],
                    correct: 0,
                    explanation: "setAccessible(true) bypasses access control checks for private members.",
                    difficulty: "medium"
                },
                {
                    question: "What is Method.invoke() used for?",
                    options: ["Call method dynamically at runtime", "Define method", "Delete method", "Rename method", "Copy method", "Move method", "Hide method"],
                    correct: 0,
                    explanation: "invoke() calls a method on an object with specified arguments at runtime.",
                    difficulty: "medium"
                },
                {
                    question: "What are the disadvantages of reflection?",
                    options: ["Performance overhead and security concerns", "No disadvantages", "Faster execution", "Better security", "Simpler code", "Smaller bytecode", "Better type safety"],
                    correct: 0,
                    explanation: "Reflection is slower, bypasses compile-time checks, and can break encapsulation.",
                    difficulty: "medium"
                },
                {
                    question: "How do you get all methods of a class?",
                    options: ["class.getMethods() or getDeclaredMethods()", "class.methods()", "class.allMethods()", "class.listMethods()", "class.findMethods()", "class.showMethods()", "class.printMethods()"],
                    correct: 0,
                    explanation: "getMethods() returns public methods including inherited; getDeclaredMethods() returns all declared methods.",
                    difficulty: "medium"
                },
                {
                    question: "What is a dynamic proxy?",
                    options: ["Runtime-generated class implementing interfaces", "Static proxy", "Compile-time proxy", "Design pattern only", "Abstract class", "Final class", "Inner class"],
                    correct: 0,
                    explanation: "Dynamic proxies are created at runtime using Proxy.newProxyInstance() to implement interfaces.",
                    difficulty: "hard"
                },
                {
                    question: "What is the InvocationHandler interface?",
                    options: ["Handles method calls on dynamic proxy", "Creates proxies", "Deletes proxies", "Validates proxies", "Caches proxies", "Pools proxies", "Manages proxies"],
                    correct: 0,
                    explanation: "InvocationHandler's invoke() method is called for every method invocation on the proxy.",
                    difficulty: "hard"
                }
            ],
            modules: [
                {
                    question: "What is the Java Platform Module System (JPMS)?",
                    options: ["System for modularizing Java applications (Java 9+)", "Package system", "Class system", "Method system", "Variable system", "Import system", "Export system"],
                    correct: 0,
                    explanation: "JPMS (Project Jigsaw) provides strong encapsulation and explicit dependencies for Java applications.",
                    difficulty: "easy"
                },
                {
                    question: "What file defines a module?",
                    options: ["module-info.java", "module.java", "Module.java", "module-def.java", "module.xml", "module.json", "module.properties"],
                    correct: 0,
                    explanation: "module-info.java in the module root defines the module's name, exports, and requirements.",
                    difficulty: "easy"
                },
                {
                    question: "What keyword declares a module?",
                    options: ["module", "package", "import", "export", "require", "class", "interface"],
                    correct: 0,
                    explanation: "The 'module' keyword declares a module in module-info.java.",
                    difficulty: "easy"
                },
                {
                    question: "What does 'requires' directive do?",
                    options: ["Declares dependency on another module", "Exports packages", "Opens packages", "Uses services", "Provides services", "Contains packages", "Imports classes"],
                    correct: 0,
                    explanation: "'requires' specifies that this module depends on another module.",
                    difficulty: "medium"
                },
                {
                    question: "What does 'exports' directive do?",
                    options: ["Makes package accessible to other modules", "Requires modules", "Opens packages", "Uses services", "Provides services", "Contains packages", "Imports classes"],
                    correct: 0,
                    explanation: "'exports' makes a package's public types accessible to other modules.",
                    difficulty: "medium"
                },
                {
                    question: "What is the difference between exports and opens?",
                    options: ["exports for compile-time, opens for reflection at runtime", "They are identical", "opens for compile-time", "exports for runtime", "opens is deprecated", "exports is deprecated", "No difference"],
                    correct: 0,
                    explanation: "'exports' allows compile-time access; 'opens' allows deep reflection at runtime.",
                    difficulty: "hard"
                },
                {
                    question: "What is 'requires transitive'?",
                    options: ["Dependency is passed to modules that require this module", "Private dependency", "Optional dependency", "Static dependency", "Weak dependency", "Strong dependency", "Local dependency"],
                    correct: 0,
                    explanation: "'requires transitive' makes the dependency available to modules depending on this module.",
                    difficulty: "hard"
                },
                {
                    question: "What is an automatic module?",
                    options: ["JAR on module path without module-info.java", "Manual module", "Named module", "Unnamed module", "System module", "Platform module", "Application module"],
                    correct: 0,
                    explanation: "Automatic modules are created from JARs without module-info.java placed on the module path.",
                    difficulty: "hard"
                },
                {
                    question: "What is the unnamed module?",
                    options: ["Module containing classes from classpath", "Named module", "Automatic module", "System module", "Platform module", "Application module", "Base module"],
                    correct: 0,
                    explanation: "The unnamed module contains all classes loaded from the classpath.",
                    difficulty: "hard"
                },
                {
                    question: "What is 'uses' directive for?",
                    options: ["Declares that module uses a service", "Provides service", "Exports package", "Requires module", "Opens package", "Contains package", "Imports class"],
                    correct: 0,
                    explanation: "'uses' declares that the module consumes a service interface (ServiceLoader).",
                    difficulty: "hard"
                }
            ],
            records: [
                {
                    question: "What is a record in Java?",
                    options: ["Immutable data carrier class (Java 14+)", "Mutable class", "Abstract class", "Interface", "Enum", "Annotation", "Module"],
                    correct: 0,
                    explanation: "Records are immutable data classes that automatically generate constructors, accessors, equals, hashCode, toString.",
                    difficulty: "easy"
                },
                {
                    question: "How do you declare a record?",
                    options: ["record Name(Type field, ...)", "class Name record", "record class Name", "data class Name", "struct Name", "tuple Name", "case class Name"],
                    correct: 0,
                    explanation: "Records are declared with 'record' keyword followed by name and component list.",
                    difficulty: "easy"
                },
                {
                    question: "Are record fields mutable?",
                    options: ["No, record fields are final", "Yes, always mutable", "Depends on type", "Only primitives", "Only objects", "Configurable", "Sometimes"],
                    correct: 0,
                    explanation: "Record components are implicitly final; records are designed to be immutable.",
                    difficulty: "easy"
                },
                {
                    question: "Can records extend other classes?",
                    options: ["No, records implicitly extend Record class", "Yes, any class", "Only abstract classes", "Only other records", "Only interfaces", "Only Object", "Only final classes"],
                    correct: 0,
                    explanation: "Records implicitly extend java.lang.Record and cannot extend other classes.",
                    difficulty: "medium"
                },
                {
                    question: "Can records implement interfaces?",
                    options: ["Yes, records can implement interfaces", "No, never", "Only Serializable", "Only Comparable", "Only functional interfaces", "Only marker interfaces", "Only one interface"],
                    correct: 0,
                    explanation: "Records can implement any number of interfaces.",
                    difficulty: "medium"
                },
                {
                    question: "What is a compact constructor in records?",
                    options: ["Constructor without parameter list for validation", "Default constructor", "Copy constructor", "Private constructor", "Static constructor", "Abstract constructor", "Final constructor"],
                    correct: 0,
                    explanation: "Compact constructors omit the parameter list and are used for validation/normalization.",
                    difficulty: "medium"
                },
                {
                    question: "What is a sealed class?",
                    options: ["Class that restricts which classes can extend it", "Final class", "Abstract class", "Open class", "Public class", "Private class", "Protected class"],
                    correct: 0,
                    explanation: "Sealed classes (Java 17) explicitly list permitted subclasses using 'permits' clause.",
                    difficulty: "medium"
                },
                {
                    question: "What keyword is used with sealed classes to list subclasses?",
                    options: ["permits", "allows", "extends", "implements", "includes", "contains", "accepts"],
                    correct: 0,
                    explanation: "'permits' clause lists the classes allowed to extend the sealed class.",
                    difficulty: "medium"
                },
                {
                    question: "What must a subclass of a sealed class be?",
                    options: ["final, sealed, or non-sealed", "Only final", "Only sealed", "Only abstract", "Only public", "Only private", "Any modifier"],
                    correct: 0,
                    explanation: "Subclasses must be final (no further extension), sealed (controlled extension), or non-sealed (open).",
                    difficulty: "hard"
                },
                {
                    question: "Can records be used in switch expressions with pattern matching?",
                    options: ["Yes, with record patterns (Java 21)", "No, never", "Only with instanceof", "Only with equals", "Only with hashCode", "Only with toString", "Only with compareTo"],
                    correct: 0,
                    explanation: "Record patterns allow deconstructing records in switch expressions and instanceof.",
                    difficulty: "hard"
                }
            ],
            bestpractices: [
                {
                    question: "What is the Single Responsibility Principle?",
                    options: ["A class should have only one reason to change", "A class should do everything", "A class should be final", "A class should be abstract", "A class should be public", "A class should be private", "A class should be static"],
                    correct: 0,
                    explanation: "SRP states that a class should have only one responsibility or reason to change.",
                    difficulty: "easy"
                },
                {
                    question: "What is the DRY principle?",
                    options: ["Don't Repeat Yourself - avoid code duplication", "Do Repeat Yourself", "Delete Repeated Yields", "Duplicate Required Yields", "Don't Run Yields", "Do Run Yields", "Delete Run Yields"],
                    correct: 0,
                    explanation: "DRY principle advocates avoiding duplication of code and logic.",
                    difficulty: "easy"
                },
                {
                    question: "Why should you prefer composition over inheritance?",
                    options: ["More flexible and avoids tight coupling", "Inheritance is always better", "Composition is slower", "Inheritance is more flexible", "Composition is deprecated", "Inheritance is newer", "Composition is harder"],
                    correct: 0,
                    explanation: "Composition provides more flexibility and looser coupling than inheritance.",
                    difficulty: "medium"
                },
                {
                    question: "What is the Open/Closed Principle?",
                    options: ["Open for extension, closed for modification", "Open for modification", "Closed for extension", "Always open", "Always closed", "Never open", "Never closed"],
                    correct: 0,
                    explanation: "OCP states that classes should be open for extension but closed for modification.",
                    difficulty: "medium"
                },
                {
                    question: "Why should fields be private?",
                    options: ["Encapsulation - control access and modification", "Performance improvement", "Memory savings", "Compilation requirement", "JVM requirement", "Security requirement", "Syntax requirement"],
                    correct: 0,
                    explanation: "Private fields enforce encapsulation, allowing controlled access through methods.",
                    difficulty: "easy"
                },
                {
                    question: "What is the Liskov Substitution Principle?",
                    options: ["Subtypes must be substitutable for their base types", "Base types substitute subtypes", "No substitution allowed", "Only interfaces substitute", "Only abstract classes substitute", "Only final classes substitute", "Only records substitute"],
                    correct: 0,
                    explanation: "LSP states that objects of a superclass should be replaceable with objects of subclasses.",
                    difficulty: "hard"
                },
                {
                    question: "Why use interfaces for dependencies?",
                    options: ["Loose coupling and easier testing", "Tight coupling", "Faster execution", "Smaller code", "Better security", "Less memory", "Simpler syntax"],
                    correct: 0,
                    explanation: "Programming to interfaces allows swapping implementations and easier unit testing.",
                    difficulty: "medium"
                },
                {
                    question: "What is the Interface Segregation Principle?",
                    options: ["Clients shouldn't depend on methods they don't use", "One large interface is better", "Interfaces should have many methods", "Interfaces should be empty", "Interfaces should be final", "Interfaces should be abstract", "Interfaces should be private"],
                    correct: 0,
                    explanation: "ISP advocates for smaller, specific interfaces rather than large, general ones.",
                    difficulty: "hard"
                },
                {
                    question: "Why prefer immutable objects?",
                    options: ["Thread-safe, simpler, no defensive copies needed", "Mutable is always better", "Immutable is slower", "Immutable uses more memory", "Immutable is deprecated", "Immutable is harder", "Immutable is newer"],
                    correct: 0,
                    explanation: "Immutable objects are inherently thread-safe and easier to reason about.",
                    difficulty: "medium"
                },
                {
                    question: "What is the Dependency Inversion Principle?",
                    options: ["Depend on abstractions, not concretions", "Depend on concretions", "No dependencies allowed", "Only concrete dependencies", "Only abstract dependencies", "Only interface dependencies", "Only class dependencies"],
                    correct: 0,
                    explanation: "DIP states that high-level modules should depend on abstractions, not low-level modules.",
                    difficulty: "hard"
                }
            ]
        };

        // Category display names
        const categoryNames = {
            basics: "Java Basics",
            oop: "OOP Concepts",
            classes: "Classes & Objects",
            inheritance: "Inheritance",
            interfaces: "Interfaces & Abstract",
            exceptions: "Exception Handling",
            collections: "Collections Framework",
            generics: "Generics",
            streams: "Streams API",
            lambdas: "Lambda Expressions",
            multithreading: "Multithreading",
            io: "I/O & NIO",
            jdbc: "JDBC",
            strings: "Strings",
            memory: "Memory Management",
            annotations: "Annotations",
            reflection: "Reflection",
            modules: "Modules (JPMS)",
            records: "Records & Sealed",
            bestpractices: "Best Practices"
        };

        // Local storage keys
        const STORAGE_KEYS = {
            settings: 'javaQuiz_settings',
            quizState: 'javaQuiz_state'
        };

        // Quiz state
        let currentQuiz = [];
        let currentQuestionIndex = 0;
        let correctAnswers = 0;
        let wrongAnswers = 0;
        let answered = false;
        let categoryScores = {};
        let answeredQuestions = [];
        
        // Timer state
        let timerInterval = null;
        let questionTimeLimit = 30;
        let questionTimeRemaining = 30;
        let totalTimeElapsed = 0;
        let quizStartTime = null;
        let timeUpHandled = false;

        // Save settings to localStorage
        function saveSettings() {
            const settings = {
                category: document.getElementById('categorySelect').value,
                difficulty: document.getElementById('difficultySelect').value,
                questionCount: document.getElementById('questionCount').value,
                timer: document.getElementById('timerSelect').value
            };
            localStorage.setItem(STORAGE_KEYS.settings, JSON.stringify(settings));
        }

        // Load settings from localStorage
        function loadSettings() {
            const saved = localStorage.getItem(STORAGE_KEYS.settings);
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    if (settings.category) document.getElementById('categorySelect').value = settings.category;
                    if (settings.difficulty) document.getElementById('difficultySelect').value = settings.difficulty;
                    if (settings.questionCount) document.getElementById('questionCount').value = settings.questionCount;
                    if (settings.timer) document.getElementById('timerSelect').value = settings.timer;
                } catch (e) {
                    console.error('Error loading settings:', e);
                }
            }
        }

        // Save quiz state to localStorage
        function saveQuizState() {
            const state = {
                currentQuiz: currentQuiz,
                currentQuestionIndex: currentQuestionIndex,
                correctAnswers: correctAnswers,
                wrongAnswers: wrongAnswers,
                categoryScores: categoryScores,
                answeredQuestions: answeredQuestions,
                questionTimeLimit: questionTimeLimit,
                quizStartTime: quizStartTime,
                totalTimeElapsed: totalTimeElapsed
            };
            localStorage.setItem(STORAGE_KEYS.quizState, JSON.stringify(state));
        }

        // Load quiz state from localStorage
        function loadQuizState() {
            const saved = localStorage.getItem(STORAGE_KEYS.quizState);
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading quiz state:', e);
                    return null;
                }
            }
            return null;
        }

        // Clear quiz state from localStorage
        function clearQuizState() {
            localStorage.removeItem(STORAGE_KEYS.quizState);
        }

        // Check for saved quiz state on page load
        function checkForSavedQuiz() {
            const savedState = loadQuizState();
            if (savedState && savedState.currentQuiz && savedState.currentQuiz.length > 0) {
                const answeredCount = savedState.answeredQuestions ? savedState.answeredQuestions.length : 0;
                const totalCount = savedState.currentQuiz.length;
                
                // Only show resume if quiz is not complete
                if (answeredCount < totalCount) {
                    const resumeBanner = document.getElementById('resumeBanner');
                    const resumeInfo = document.getElementById('resumeInfo');
                    
                    resumeInfo.textContent = `Progress: ${answeredCount}/${totalCount} questions answered (${savedState.correctAnswers} correct, ${savedState.wrongAnswers} wrong)`;
                    resumeBanner.style.display = 'flex';
                }
            }
        }

        // Resume saved quiz
        function resumeQuiz() {
            const savedState = loadQuizState();
            if (savedState) {
                currentQuiz = savedState.currentQuiz;
                currentQuestionIndex = savedState.currentQuestionIndex;
                correctAnswers = savedState.correctAnswers;
                wrongAnswers = savedState.wrongAnswers;
                categoryScores = savedState.categoryScores;
                answeredQuestions = savedState.answeredQuestions || [];
                questionTimeLimit = savedState.questionTimeLimit;
                quizStartTime = savedState.quizStartTime;
                totalTimeElapsed = savedState.totalTimeElapsed || 0;

                document.getElementById('startScreen').style.display = 'none';
                document.getElementById('progressContainer').style.display = 'block';
                document.getElementById('totalQuestions').textContent = currentQuiz.length;

                // Start elapsed time counter if no timer
                if (questionTimeLimit === 0) {
                    timerInterval = setInterval(() => {
                        updateTimerDisplay();
                    }, 1000);
                }

                renderQuestion();
            }
        }

        // Dismiss resume banner
        function dismissResume() {
            document.getElementById('resumeBanner').style.display = 'none';
            clearQuizState();
        }

        // Shuffle array helper
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Get 5 random options from 7, always including the correct answer
        function getRandomOptions(question) {
            const correctOption = question.options[question.correct];
            const otherOptions = question.options.filter((_, index) => index !== question.correct);
            
            // Shuffle other options and take 4
            const shuffledOthers = shuffleArray(otherOptions).slice(0, 4);
            
            // Combine correct answer with 4 random others
            const selectedOptions = [correctOption, ...shuffledOthers];
            
            // Shuffle the combined options
            const shuffledOptions = shuffleArray(selectedOptions);
            
            // Find new correct index
            const newCorrectIndex = shuffledOptions.indexOf(correctOption);
            
            return {
                options: shuffledOptions,
                correctIndex: newCorrectIndex
            };
        }

        // Format time as MM:SS
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // Start question timer
        function startTimer() {
            if (questionTimeLimit === 0) return; // No timer mode
            
            questionTimeRemaining = questionTimeLimit;
            timeUpHandled = false;
            updateTimerDisplay();
            
            timerInterval = setInterval(() => {
                questionTimeRemaining--;
                updateTimerDisplay();
                
                if (questionTimeRemaining <= 0) {
                    clearInterval(timerInterval);
                    handleTimeUp();
                }
            }, 1000);
        }

        // Stop timer
        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        // Update timer display
        function updateTimerDisplay() {
            const timerElement = document.getElementById('timer');
            if (questionTimeLimit === 0) {
                // Show elapsed time instead
                const elapsed = Math.floor((Date.now() - quizStartTime) / 1000);
                timerElement.textContent = formatTime(elapsed);
                timerElement.className = 'timer';
            } else {
                timerElement.textContent = formatTime(questionTimeRemaining);
                
                // Add warning classes
                timerElement.classList.remove('warning', 'danger');
                if (questionTimeRemaining <= 5) {
                    timerElement.classList.add('danger');
                } else if (questionTimeRemaining <= 10) {
                    timerElement.classList.add('warning');
                }
            }
        }

        // Handle time up - inline message instead of popup
        function handleTimeUp() {
            if (timeUpHandled || answered) return;
            timeUpHandled = true;
            answered = true;
            
            // Mark as wrong answer
            wrongAnswers++;
            
            // Track answered question
            answeredQuestions.push({
                index: currentQuestionIndex,
                selectedOption: -1,
                correct: false,
                timedOut: true
            });
            
            const q = currentQuiz[currentQuestionIndex];
            const options = document.querySelectorAll('.option');
            
            // Show time up message
            const timeUpMsg = document.getElementById('timeUpMessage');
            if (timeUpMsg) {
                timeUpMsg.classList.add('show');
            }
            
            options.forEach((opt, i) => {
                opt.classList.add('disabled');
                if (i === q.displayCorrect) {
                    opt.classList.add('show-correct');
                }
            });
            
            document.getElementById('explanation').classList.add('show');
            document.getElementById('nextBtn').disabled = false;
            updateProgress();
            saveQuizState();
        }

        // Escape HTML to prevent XSS and display issues
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Start quiz
        function startQuiz() {
            const category = document.getElementById('categorySelect').value;
            const difficulty = document.getElementById('difficultySelect').value;
            const count = parseInt(document.getElementById('questionCount').value);
            questionTimeLimit = parseInt(document.getElementById('timerSelect').value);

            // Save settings
            saveSettings();

            // Gather questions
            let questions = [];
            
            if (category === 'all') {
                // Get questions from all categories
                Object.keys(allQuestions).forEach(cat => {
                    allQuestions[cat].forEach(q => {
                        questions.push({ ...q, category: cat });
                    });
                });
            } else {
                // Get questions from selected category
                allQuestions[category].forEach(q => {
                    questions.push({ ...q, category: category });
                });
            }

            // Filter by difficulty
            if (difficulty !== 'all') {
                questions = questions.filter(q => q.difficulty === difficulty);
            }

            // Shuffle and select questions
            questions = shuffleArray(questions).slice(0, Math.min(count, questions.length));

            // Process each question to get random 5 options
            currentQuiz = questions.map(q => {
                const randomized = getRandomOptions(q);
                return {
                    ...q,
                    displayOptions: randomized.options,
                    displayCorrect: randomized.correctIndex
                };
            });

            // Reset state
            currentQuestionIndex = 0;
            correctAnswers = 0;
            wrongAnswers = 0;
            answered = false;
            categoryScores = {};
            answeredQuestions = [];
            totalTimeElapsed = 0;
            quizStartTime = Date.now();

            // Initialize category scores
            Object.keys(categoryNames).forEach(cat => {
                categoryScores[cat] = { correct: 0, total: 0 };
            });

            // Update UI
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('totalQuestions').textContent = currentQuiz.length;

            // Start elapsed time counter if no timer
            if (questionTimeLimit === 0) {
                timerInterval = setInterval(() => {
                    updateTimerDisplay();
                }, 1000);
            }

            // Save initial state
            saveQuizState();

            renderQuestion();
        }

        // Render current question
        function renderQuestion() {
            stopTimer();
            answered = false;
            timeUpHandled = false;
            
            const q = currentQuiz[currentQuestionIndex];
            const container = document.getElementById('questionsContainer');
            
            const letters = ['A', 'B', 'C', 'D', 'E'];
            
            container.innerHTML = `
                <div class="question-card active">
                    <div class="question-meta">
                        <span class="question-number">Question ${currentQuestionIndex + 1}</span>
                        <span class="question-category">${categoryNames[q.category]}</span>
                        <span class="question-difficulty ${q.difficulty}">${q.difficulty.charAt(0).toUpperCase() + q.difficulty.slice(1)}</span>
                    </div>
                    
                    <div class="time-up-message" id="timeUpMessage">
                        <span class="time-icon">‚è∞</span>
                        <div class="time-text">
                            <strong>Time's Up!</strong>
                            <span>The correct answer is highlighted below.</span>
                        </div>
                    </div>
                    
                    <div class="question-text">${escapeHtml(q.question)}</div>
                    
                    <div class="options">
                        ${q.displayOptions.map((opt, i) => `
                            <div class="option" onclick="selectOption(${i})" data-index="${i}">
                                <span class="option-letter">${letters[i]}</span>
                                <span class="option-text">${escapeHtml(opt)}</span>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div class="explanation" id="explanation">
                        <h4>üí° Explanation</h4>
                        <p>${escapeHtml(q.explanation)}</p>
                    </div>
                    
                    <div class="btn-container">
                        <button class="btn btn-primary" id="nextBtn" onclick="nextQuestion()" disabled>
                            ${currentQuestionIndex < currentQuiz.length - 1 ? 'Next Question ‚Üí' : 'See Results üèÜ'}
                        </button>
                    </div>
                    
                    <div class="quit-btn-container">
                        <button class="btn btn-secondary" onclick="quitQuiz()" style="padding: 8px 20px; font-size: 0.9rem;">
                            üö™ Quit Quiz
                        </button>
                    </div>
                </div>
            `;

            updateProgress();
            
            // Start timer for this question
            if (questionTimeLimit > 0) {
                startTimer();
            }
        }

        // Select option
        function selectOption(index) {
            if (answered) return;
            answered = true;
            
            stopTimer();
            
            const q = currentQuiz[currentQuestionIndex];
            const options = document.querySelectorAll('.option');
            const isCorrect = index === q.displayCorrect;
            
            // Track answered question
            answeredQuestions.push({
                index: currentQuestionIndex,
                selectedOption: index,
                correct: isCorrect,
                timedOut: false
            });
            
            // Update scores
            if (isCorrect) {
                correctAnswers++;
                options[index].classList.add('correct');
            } else {
                wrongAnswers++;
                options[index].classList.add('incorrect');
                options[q.displayCorrect].classList.add('show-correct');
            }
            
            // Update category score
            categoryScores[q.category].total++;
            if (isCorrect) {
                categoryScores[q.category].correct++;
            }
            
            // Disable all options
            options.forEach(opt => opt.classList.add('disabled'));
            
            // Show explanation
            document.getElementById('explanation').classList.add('show');
            
            // Enable next button
            document.getElementById('nextBtn').disabled = false;
            
            updateProgress();
            saveQuizState();
        }

        // Update progress display
        function updateProgress() {
            const progress = ((currentQuestionIndex + 1) / currentQuiz.length) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;
            document.getElementById('currentQuestion').textContent = currentQuestionIndex + 1;
            document.getElementById('correctCount').textContent = correctAnswers;
            document.getElementById('wrongCount').textContent = wrongAnswers;
            
            const total = correctAnswers + wrongAnswers;
            const score = total > 0 ? Math.round((correctAnswers / total) * 100) : 0;
            document.getElementById('currentScore').textContent = score;
        }

        // Next question
        function nextQuestion() {
            currentQuestionIndex++;
            
            if (currentQuestionIndex >= currentQuiz.length) {
                showResults();
            } else {
                saveQuizState();
                renderQuestion();
            }
        }

        // Quit quiz
        function quitQuiz() {
            if (confirm('Are you sure you want to quit? Your progress will be saved and you can resume later.')) {
                stopTimer();
                saveQuizState();
                backToMenu();
            }
        }

        // Show results
        function showResults() {
            stopTimer();
            clearQuizState(); // Clear saved state when quiz is complete
            
            // Calculate total time
            const totalTime = Math.floor((Date.now() - quizStartTime) / 1000);
            
            document.getElementById('questionsContainer').innerHTML = '';
            document.getElementById('progressContainer').style.display = 'none';
            
            const score = Math.round((correctAnswers / currentQuiz.length) * 100);
            
            document.getElementById('finalScore').textContent = `${score}%`;
            document.getElementById('finalCorrect').textContent = correctAnswers;
            document.getElementById('finalWrong').textContent = wrongAnswers;
            document.getElementById('finalTime').textContent = formatTime(totalTime);
            
            // Set message based on score
            let message, details;
            if (score >= 90) {
                message = "üèÜ Outstanding! Java Master!";
                details = "You have exceptional Java knowledge!";
            } else if (score >= 70) {
                message = "üåü Great Job! Well Done!";
                details = "You have solid Java fundamentals!";
            } else if (score >= 50) {
                message = "üëç Good Effort! Keep Learning!";
                details = "You're on the right track!";
            } else {
                message = "üìö Keep Practicing!";
                details = "Review the topics and try again!";
            }
            
            document.getElementById('resultsMessage').textContent = message;
            document.getElementById('resultsDetails').textContent = details;
            
            // Render category scores
            const categoryScoresDiv = document.getElementById('categoryScores');
            let categoryHtml = '';
            
            Object.keys(categoryScores).forEach(cat => {
                const catScore = categoryScores[cat];
                if (catScore.total > 0) {
                    const percentage = Math.round((catScore.correct / catScore.total) * 100);
                    categoryHtml += `
                        <div class="category-score-item">
                            <span class="category-name">${categoryNames[cat]}</span>
                            <span class="category-score-value">${catScore.correct}/${catScore.total}</span>
                            <div class="category-score-bar">
                                <div class="category-score-fill" style="width: ${percentage}%"></div>
                            </div>
                        </div>
                    `;
                }
            });
            
            categoryScoresDiv.innerHTML = categoryHtml || '<p>No category data available</p>';
            
            document.getElementById('resultsCard').classList.add('active');
        }

        // Restart quiz with same settings
        function restartQuiz() {
            document.getElementById('resultsCard').classList.remove('active');
            startQuiz();
        }

        // Back to menu
        function backToMenu() {
            stopTimer();
            document.getElementById('resultsCard').classList.remove('active');
            document.getElementById('questionsContainer').innerHTML = '';
            document.getElementById('progressContainer').style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
            
            // Check for any saved quiz state
            checkForSavedQuiz();
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadSettings();
            checkForSavedQuiz();
        });
    </script>
</body>
</html>
