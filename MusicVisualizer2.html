<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Music Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #ec4899;
            --bg-dark: #0f0f1a;
            --bg-card: #1a1a2e;
            --bg-input: #252540;
            --text: #ffffff;
            --text-muted: #a0a0b0;
            --border: #333355;
            --success: #22c55e;
            --danger: #ef4444;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* Header */
        .header {
            background: var(--bg-card);
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
            gap: 10px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.3rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .logo svg {
            width: 32px;
            height: 32px;
        }

        .header-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .btn svg {
            width: 18px;
            height: 18px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
        }

        .btn-secondary {
            background: var(--bg-input);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .btn-icon {
            padding: 8px;
            border-radius: 50%;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        /* Main Content */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 300px;
            background: var(--bg-card);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
        }

        .sidebar.hidden {
            transform: translateX(-100%);
            position: absolute;
            z-index: 100;
            height: calc(100vh - 60px);
        }

        .sidebar-header {
            padding: 15px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-title {
            font-size: 1rem;
            font-weight: 600;
        }

        .library-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .library-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
            margin-bottom: 5px;
        }

        .library-item:hover {
            background: var(--bg-input);
        }

        .library-item.active {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(236, 72, 153, 0.2));
            border: 1px solid var(--primary);
        }

        .library-item-icon {
            width: 40px;
            height: 40px;
            background: var(--bg-input);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .library-item-info {
            flex: 1;
            overflow: hidden;
        }

        .library-item-name {
            font-size: 0.9rem;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .library-item-size {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .library-item-actions {
            display: flex;
            gap: 5px;
        }

        .library-item-actions .btn {
            padding: 5px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .library-item:hover .library-item-actions .btn {
            opacity: 1;
        }

        /* Visualizer Area */
        .visualizer-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0f0f1a 100%);
        }

        #visualizer {
            width: 100%;
            height: 100%;
            display: block;
        }

        .visualizer-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }

        .viz-info {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }

        .viz-info h2 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 5px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .viz-info p {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        /* Controls Panel */
        .controls-panel {
            background: var(--bg-card);
            border-top: 1px solid var(--border);
            padding: 15px 20px;
        }

        .progress-container {
            margin-bottom: 15px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: var(--bg-input);
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }

        .progress-bar:hover .progress-fill {
            height: 8px;
            margin-top: -1px;
        }

        .time-display {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 5px;
        }

        .main-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .play-btn {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .play-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(99, 102, 241, 0.5);
        }

        .play-btn svg {
            width: 24px;
            height: 24px;
            fill: white;
        }

        .control-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--bg-input);
            border: 1px solid var(--border);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text);
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: var(--border);
        }

        .control-btn.active {
            color: var(--primary);
            border-color: var(--primary);
        }

        .control-btn svg {
            width: 20px;
            height: 20px;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .volume-slider {
            width: 100px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--bg-input);
            border-radius: 2px;
            cursor: pointer;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
        }

        /* Settings Panel */
        .settings-panel {
            position: absolute;
            top: 0;
            right: 0;
            width: 320px;
            height: 100%;
            background: var(--bg-card);
            border-left: 1px solid var(--border);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 100;
            overflow-y: auto;
        }

        .settings-panel.open {
            transform: translateX(0);
        }

        .settings-header {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .settings-content {
            padding: 20px;
        }

        .setting-group {
            margin-bottom: 25px;
        }

        .setting-label {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 10px;
            display: block;
        }

        .setting-options {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .setting-option {
            padding: 8px 16px;
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .setting-option:hover {
            border-color: var(--primary);
        }

        .setting-option.active {
            background: var(--primary);
            border-color: var(--primary);
        }

        .color-options {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
        }

        .color-option {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: transform 0.2s, border-color 0.2s;
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.active {
            border-color: white;
        }

        .range-control {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .range-slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--bg-input);
            border-radius: 3px;
            cursor: pointer;
        }

        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 50%;
            cursor: pointer;
        }

        .range-value {
            min-width: 40px;
            text-align: right;
            font-size: 0.9rem;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }

        .modal-overlay.open {
            display: flex;
        }

        .modal {
            background: var(--bg-card);
            border-radius: 16px;
            width: 100%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .modal-body {
            padding: 20px;
        }

        .upload-area {
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-area:hover, .upload-area.dragover {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.1);
        }

        .upload-area svg {
            width: 48px;
            height: 48px;
            margin-bottom: 15px;
            color: var(--primary);
        }

        .upload-area h3 {
            font-size: 1.1rem;
            margin-bottom: 5px;
        }

        .upload-area p {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .file-input {
            display: none;
        }

        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            text-align: center;
            color: var(--text-muted);
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        /* Toggle Button for Mobile */
        .sidebar-toggle {
            display: none;
            position: fixed;
            bottom: 140px;
            left: 20px;
            z-index: 50;
        }

        /* Responsive Styles */
        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                left: 0;
                top: 60px;
                height: calc(100% - 60px);
                z-index: 100;
                transform: translateX(-100%);
            }

            .sidebar.open {
                transform: translateX(0);
            }

            .sidebar-toggle {
                display: flex;
            }

            .header-actions {
                flex: 1;
                justify-content: flex-end;
            }

            .logo span {
                display: none;
            }

            .visualizer-overlay {
                top: 10px;
                right: 10px;
            }

            .main-controls {
                gap: 10px;
            }

            .volume-control {
                display: none;
            }

            .settings-panel {
                width: 100%;
            }

            .btn span {
                display: none;
            }

            .btn svg {
                margin: 0;
            }
        }

        @media (max-width: 480px) {
            .header {
                padding: 10px 15px;
            }

            .controls-panel {
                padding: 10px 15px;
            }

            .play-btn {
                width: 48px;
                height: 48px;
            }

            .control-btn {
                width: 36px;
                height: 36px;
            }

            .viz-info h2 {
                font-size: 1.2rem;
            }
        }

        /* Landscape Mode */
        @media (max-height: 500px) and (orientation: landscape) {
            .controls-panel {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                padding: 8px 15px;
            }

            .progress-container {
                margin-bottom: 8px;
            }

            .play-btn {
                width: 40px;
                height: 40px;
            }

            .control-btn {
                width: 32px;
                height: 32px;
            }

            .viz-info {
                bottom: 80px;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }

        /* Animations */
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .playing .play-btn {
            animation: pulse 1s ease-in-out infinite;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            bottom: 100px;
            right: 20px;
            z-index: 1001;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toast {
            background: var(--bg-card);
            border: 1px solid var(--border);
            padding: 12px 20px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: slideIn 0.3s ease;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .toast.success {
            border-color: var(--success);
        }

        .toast.error {
            border-color: var(--danger);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Storage Info */
        .storage-info {
            padding: 15px;
            background: var(--bg-input);
            border-radius: 8px;
            margin-top: 15px;
        }

        .storage-bar {
            height: 8px;
            background: var(--bg-dark);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .storage-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            transition: width 0.3s;
        }

        .storage-text {
            font-size: 0.8rem;
            color: var(--text-muted);
            display: flex;
            justify-content: space-between;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="logo">
                <svg viewBox="0 0 24 24" fill="none" stroke="url(#gradient)" stroke-width="2">
                    <defs>
                        <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#6366f1"/>
                            <stop offset="100%" style="stop-color:#ec4899"/>
                        </linearGradient>
                    </defs>
                    <path d="M9 18V5l12-2v13"/>
                    <circle cx="6" cy="18" r="3"/>
                    <circle cx="18" cy="16" r="3"/>
                </svg>
                <span>Music Visualizer</span>
            </div>
            <div class="header-actions">
                <button class="btn btn-primary" id="uploadBtn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="17 8 12 3 7 8"/>
                        <line x1="12" y1="3" x2="12" y2="15"/>
                    </svg>
                    <span>Upload</span>
                </button>
                <button class="btn btn-secondary" id="settingsBtn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="3"/>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                    </svg>
                    <span>Settings</span>
                </button>
            </div>
        </header>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Sidebar - Library -->
            <aside class="sidebar" id="sidebar">
                <div class="sidebar-header">
                    <span class="sidebar-title">Music Library</span>
                    <button class="btn btn-icon btn-secondary" id="closeSidebar">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                            <line x1="18" y1="6" x2="6" y2="18"/>
                            <line x1="6" y1="6" x2="18" y2="18"/>
                        </svg>
                    </button>
                </div>
                <div class="library-list" id="libraryList">
                    <div class="empty-state" id="emptyLibrary">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M9 18V5l12-2v13"/>
                            <circle cx="6" cy="18" r="3"/>
                            <circle cx="18" cy="16" r="3"/>
                        </svg>
                        <p>No music yet</p>
                        <p>Upload some tracks to get started</p>
                    </div>
                </div>
                <div class="storage-info">
                    <div style="font-size: 0.9rem; font-weight: 500;">Storage Used</div>
                    <div class="storage-bar">
                        <div class="storage-fill" id="storageFill" style="width: 0%"></div>
                    </div>
                    <div class="storage-text">
                        <span id="storageUsed">0 MB</span>
                        <span id="storageTotal">50 MB max</span>
                    </div>
                </div>
            </aside>

            <!-- Visualizer -->
            <div class="visualizer-area">
                <div class="canvas-container">
                    <canvas id="visualizer"></canvas>
                    <div class="viz-info" id="vizInfo">
                        <h2 id="trackName">No Track Selected</h2>
                        <p id="vizMode">Bars Visualization</p>
                    </div>
                </div>

                <div class="visualizer-overlay">
                    <button class="btn btn-secondary btn-icon" id="fullscreenBtn" title="Fullscreen">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="15 3 21 3 21 9"/>
                            <polyline points="9 21 3 21 3 15"/>
                            <line x1="21" y1="3" x2="14" y2="10"/>
                            <line x1="3" y1="21" x2="10" y2="14"/>
                        </svg>
                    </button>
                </div>

                <!-- Controls -->
                <div class="controls-panel" id="controlsPanel">
                    <div class="progress-container">
                        <div class="progress-bar" id="progressBar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <div class="time-display">
                            <span id="currentTime">0:00</span>
                            <span id="duration">0:00</span>
                        </div>
                    </div>
                    <div class="main-controls">
                        <button class="control-btn" id="prevBtn" title="Previous">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <polygon points="19 20 9 12 19 4 19 20"/>
                                <line x1="5" y1="19" x2="5" y2="5" stroke="currentColor" stroke-width="2"/>
                            </svg>
                        </button>
                        <button class="play-btn" id="playBtn" title="Play">
                            <svg viewBox="0 0 24 24" id="playIcon">
                                <polygon points="5 3 19 12 5 21 5 3"/>
                            </svg>
                        </button>
                        <button class="control-btn" id="nextBtn" title="Next">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <polygon points="5 4 15 12 5 20 5 4"/>
                                <line x1="19" y1="5" x2="19" y2="19" stroke="currentColor" stroke-width="2"/>
                            </svg>
                        </button>
                        <div class="volume-control">
                            <button class="control-btn" id="volumeBtn" title="Volume">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" id="volumeIcon">
                                    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
                                    <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/>
                                </svg>
                            </button>
                            <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="80">
                        </div>
                        <button class="control-btn" id="shuffleBtn" title="Shuffle">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="16 3 21 3 21 8"/>
                                <line x1="4" y1="20" x2="21" y2="3"/>
                                <polyline points="21 16 21 21 16 21"/>
                                <line x1="15" y1="15" x2="21" y2="21"/>
                                <line x1="4" y1="4" x2="9" y2="9"/>
                            </svg>
                        </button>
                        <button class="control-btn" id="repeatBtn" title="Repeat">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="17 1 21 5 17 9"/>
                                <path d="M3 11V9a4 4 0 0 1 4-4h14"/>
                                <polyline points="7 23 3 19 7 15"/>
                                <path d="M21 13v2a4 4 0 0 1-4 4H3"/>
                            </svg>
                        </button>
                    </div>
                </div>

                <!-- Settings Panel -->
                <div class="settings-panel" id="settingsPanel">
                    <div class="settings-header">
                        <span class="sidebar-title">Settings</span>
                        <button class="btn btn-icon btn-secondary" id="closeSettings">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                                <line x1="18" y1="6" x2="6" y2="18"/>
                                <line x1="6" y1="6" x2="18" y2="18"/>
                            </svg>
                        </button>
                    </div>
                    <div class="settings-content">
                        <div class="setting-group">
                            <label class="setting-label">Visualization Mode</label>
                            <div class="setting-options" id="vizModeOptions">
                                <span class="setting-option active" data-mode="bars">Bars</span>
                                <span class="setting-option" data-mode="wave">Wave</span>
                                <span class="setting-option" data-mode="circular">Circular</span>
                                <span class="setting-option" data-mode="particles">Particles</span>
                                <span class="setting-option" data-mode="spectrum">Spectrum</span>
                            </div>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Color Theme</label>
                            <div class="color-options" id="colorOptions">
                                <div class="color-option active" data-colors='["#6366f1", "#ec4899"]' style="background: linear-gradient(135deg, #6366f1, #ec4899)"></div>
                                <div class="color-option" data-colors='["#22c55e", "#84cc16"]' style="background: linear-gradient(135deg, #22c55e, #84cc16)"></div>
                                <div class="color-option" data-colors='["#f59e0b", "#ef4444"]' style="background: linear-gradient(135deg, #f59e0b, #ef4444)"></div>
                                <div class="color-option" data-colors='["#06b6d4", "#3b82f6"]' style="background: linear-gradient(135deg, #06b6d4, #3b82f6)"></div>
                                <div class="color-option" data-colors='["#8b5cf6", "#d946ef"]' style="background: linear-gradient(135deg, #8b5cf6, #d946ef)"></div>
                                <div class="color-option" data-colors='["#ffffff", "#888888"]' style="background: linear-gradient(135deg, #ffffff, #888888)"></div>
                                <div class="color-option" data-colors='["#ff6b6b", "#feca57"]' style="background: linear-gradient(135deg, #ff6b6b, #feca57)"></div>
                                <div class="color-option" data-colors='["#00d2d3", "#ff9ff3"]' style="background: linear-gradient(135deg, #00d2d3, #ff9ff3)"></div>
                                <div class="color-option" data-colors='["#2ed573", "#1e90ff"]' style="background: linear-gradient(135deg, #2ed573, #1e90ff)"></div>
                                <div class="color-option rainbow" data-colors='["rainbow"]' style="background: linear-gradient(90deg, red, orange, yellow, green, blue, indigo, violet)"></div>
                            </div>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Sensitivity</label>
                            <div class="range-control">
                                <input type="range" class="range-slider" id="sensitivitySlider" min="1" max="200" value="100">
                                <span class="range-value" id="sensitivityValue">100%</span>
                            </div>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Smoothing</label>
                            <div class="range-control">
                                <input type="range" class="range-slider" id="smoothingSlider" min="0" max="99" value="80">
                                <span class="range-value" id="smoothingValue">80%</span>
                            </div>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Bar Count (Bars Mode)</label>
                            <div class="range-control">
                                <input type="range" class="range-slider" id="barCountSlider" min="16" max="256" value="64">
                                <span class="range-value" id="barCountValue">64</span>
                            </div>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Background</label>
                            <div class="setting-options" id="bgOptions">
                                <span class="setting-option active" data-bg="dark">Dark</span>
                                <span class="setting-option" data-bg="gradient">Gradient</span>
                                <span class="setting-option" data-bg="reactive">Reactive</span>
                            </div>
                        </div>
                        <div class="setting-group">
                            <button class="btn btn-secondary" id="resetSettings" style="width: 100%;">
                                Reset to Defaults
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Sidebar Toggle -->
        <button class="btn btn-primary sidebar-toggle" id="sidebarToggle">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20">
                <path d="M9 18V5l12-2v13"/>
                <circle cx="6" cy="18" r="3"/>
                <circle cx="18" cy="16" r="3"/>
            </svg>
        </button>
    </div>

    <!-- Upload Modal -->
    <div class="modal-overlay" id="uploadModal">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title">Upload Music</span>
                <button class="btn btn-icon btn-secondary" id="closeModal">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
            </div>
            <div class="modal-body">
                <div class="upload-area" id="uploadArea">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="17 8 12 3 7 8"/>
                        <line x1="12" y1="3" x2="12" y2="15"/>
                    </svg>
                    <h3>Drop files here</h3>
                    <p>or click to browse</p>
                    <p style="margin-top: 10px; font-size: 0.8rem;">Supports MP3, WAV, OGG, FLAC</p>
                </div>
                <input type="file" class="file-input" id="fileInput" accept="audio/*" multiple>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <script>
        // ==================== State Management ====================
        const AppState = {
            currentTrack: null,
            isPlaying: false,
            volume: 80,
            shuffle: false,
            repeat: false,
            vizMode: 'bars',
            colors: ['#6366f1', '#ec4899'],
            sensitivity: 100,
            smoothing: 80,
            barCount: 64,
            background: 'dark',
            playlist: [],
            currentIndex: -1,

            save() {
                const state = {
                    volume: this.volume,
                    shuffle: this.shuffle,
                    repeat: this.repeat,
                    vizMode: this.vizMode,
                    colors: this.colors,
                    sensitivity: this.sensitivity,
                    smoothing: this.smoothing,
                    barCount: this.barCount,
                    background: this.background,
                    currentIndex: this.currentIndex
                };
                localStorage.setItem('musicVisualizerState', JSON.stringify(state));
            },

            load() {
                const saved = localStorage.getItem('musicVisualizerState');
                if (saved) {
                    try {
                        const state = JSON.parse(saved);
                        Object.assign(this, state);
                    } catch (e) {
                        console.error('Failed to load state:', e);
                    }
                }
            }
        };

        // ==================== IndexedDB for Audio Files ====================
        class AudioDatabase {
            constructor() {
                this.dbName = 'MusicVisualizerDB';
                this.storeName = 'audioFiles';
                this.db = null;
                this.maxStorage = 50 * 1024 * 1024;
            }

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, 1);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve();
                    };
                    
                    request.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains(this.storeName)) {
                            db.createObjectStore(this.storeName, { keyPath: 'id' });
                        }
                    };
                });
            }

            async saveFile(file) {
                const id = Date.now().toString();
                const arrayBuffer = await file.arrayBuffer();
                const record = {
                    id,
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    data: arrayBuffer,
                    addedAt: Date.now()
                };

                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.add(record);
                    
                    request.onsuccess = () => resolve(record);
                    request.onerror = () => reject(request.error);
                });
            }

            async getFile(id) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readonly');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.get(id);
                    
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async getAllFiles() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readonly');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.getAll();
                    
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(request.error);
                });
            }

            async deleteFile(id) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.delete(id);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }

            async getTotalSize() {
                const files = await this.getAllFiles();
                return files.reduce((total, file) => total + file.size, 0);
            }
        }

        // ==================== Audio Visualizer ====================
        class AudioVisualizer {
            constructor() {
                this.canvas = document.getElementById('visualizer');
                this.ctx = this.canvas.getContext('2d');
                this.audioContext = null;
                this.analyser = null;
                this.source = null;
                this.audio = new Audio();
                this.audio.crossOrigin = 'anonymous';
                this.dataArray = null;
                this.frequencyData = null;
                this.bufferLength = 0;
                this.isInitialized = false;
                this.animationId = null;
                this.particles = [];
                this.isConnected = false;
                
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                // Start idle animation
                this.animateIdle();
            }

            resize() {
                const container = this.canvas.parentElement;
                const width = container.clientWidth;
                const height = container.clientHeight;
                const dpr = window.devicePixelRatio || 1;
                
                this.canvas.width = width * dpr;
                this.canvas.height = height * dpr;
                this.canvas.style.width = width + 'px';
                this.canvas.style.height = height + 'px';
                
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.scale(dpr, dpr);
                
                this.width = width;
                this.height = height;
            }

            async init() {
                if (this.isInitialized) return;
                
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 2048;
                    this.analyser.smoothingTimeConstant = 0.8;
                    this.bufferLength = this.analyser.frequencyBinCount;
                    this.dataArray = new Uint8Array(this.bufferLength);
                    this.frequencyData = new Uint8Array(this.bufferLength);
                    
                    this.isInitialized = true;
                } catch (e) {
                    console.error('Failed to initialize audio context:', e);
                }
            }

            connectAudio() {
                if (this.isConnected || !this.audioContext) return;
                
                try {
                    this.source = this.audioContext.createMediaElementSource(this.audio);
                    this.source.connect(this.analyser);
                    this.analyser.connect(this.audioContext.destination);
                    this.isConnected = true;
                } catch (e) {
                    console.error('Failed to connect audio:', e);
                }
            }

            async loadTrack(file) {
                await this.init();
                
                // Stop current animation
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                
                // Create blob URL
                let url;
                if (file.data) {
                    const blob = new Blob([file.data], { type: file.type || 'audio/mpeg' });
                    url = URL.createObjectURL(blob);
                } else {
                    url = URL.createObjectURL(file);
                }
                
                // Set audio source
                this.audio.src = url;
                
                // Connect audio if not already connected
                this.connectAudio();
                
                return new Promise((resolve, reject) => {
                    this.audio.onloadedmetadata = () => resolve();
                    this.audio.onerror = (e) => reject(e);
                });
            }

            play() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                this.audio.play();
                this.animate();
            }

            pause() {
                this.audio.pause();
            }

            setVolume(value) {
                this.audio.volume = Math.max(0, Math.min(1, value / 100));
            }

            seek(percent) {
                if (this.audio.duration) {
                    this.audio.currentTime = (percent / 100) * this.audio.duration;
                }
            }

            getProgress() {
                if (!this.audio.duration) return 0;
                return (this.audio.currentTime / this.audio.duration) * 100;
            }

            getCurrentTime() {
                return this.formatTime(this.audio.currentTime || 0);
            }

            getDuration() {
                return this.formatTime(this.audio.duration || 0);
            }

            formatTime(seconds) {
                if (isNaN(seconds)) return '0:00';
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            animateIdle() {
                const drawIdle = () => {
                    if (this.audio && !this.audio.paused) return;
                    
                    this.animationId = requestAnimationFrame(drawIdle);
                    this.drawBackground();
                    
                    // Draw subtle idle animation
                    const time = Date.now() / 1000;
                    const barCount = AppState.barCount;
                    const barWidth = this.width / barCount;
                    
                    for (let i = 0; i < barCount; i++) {
                        const height = Math.sin(time * 2 + i * 0.1) * 10 + 15;
                        const x = i * barWidth;
                        const y = this.height - height;
                        
                        this.ctx.fillStyle = this.hexToRgba(this.getColor(i, barCount), 0.3);
                        this.ctx.fillRect(x + 1, y, barWidth - 2, height);
                    }
                };
                
                drawIdle();
            }

            animate() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                
                const draw = () => {
                    this.animationId = requestAnimationFrame(draw);
                    
                    if (this.analyser) {
                        this.analyser.smoothingTimeConstant = AppState.smoothing / 100;
                        this.analyser.getByteFrequencyData(this.frequencyData);
                        this.analyser.getByteTimeDomainData(this.dataArray);
                    }
                    
                    this.drawBackground();
                    
                    switch (AppState.vizMode) {
                        case 'bars':
                            this.drawBars();
                            break;
                        case 'wave':
                            this.drawWave();
                            break;
                        case 'circular':
                            this.drawCircular();
                            break;
                        case 'particles':
                            this.drawParticles();
                            break;
                        case 'spectrum':
                            this.drawSpectrum();
                            break;
                        default:
                            this.drawBars();
                    }
                };
                
                draw();
            }

            drawBackground() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                let avgFreq = 0;
                if (this.frequencyData) {
                    avgFreq = this.frequencyData.reduce((a, b) => a + b, 0) / this.frequencyData.length;
                }
                
                switch (AppState.background) {
                    case 'dark':
                        this.ctx.fillStyle = '#0f0f1a';
                        this.ctx.fillRect(0, 0, this.width, this.height);
                        break;
                    case 'gradient':
                        const gradient = this.ctx.createRadialGradient(
                            this.width / 2, this.height / 2, 0,
                            this.width / 2, this.height / 2, Math.max(this.width, this.height) / 2
                        );
                        gradient.addColorStop(0, '#1a1a2e');
                        gradient.addColorStop(1, '#0f0f1a');
                        this.ctx.fillStyle = gradient;
                        this.ctx.fillRect(0, 0, this.width, this.height);
                        break;
                    case 'reactive':
                        this.ctx.fillStyle = '#0f0f1a';
                        this.ctx.fillRect(0, 0, this.width, this.height);
                        
                        const intensity = avgFreq / 255 * 0.2;
                        const reactiveGradient = this.ctx.createRadialGradient(
                            this.width / 2, this.height / 2, 0,
                            this.width / 2, this.height / 2, Math.max(this.width, this.height) / 2
                        );
                        reactiveGradient.addColorStop(0, this.hexToRgba(AppState.colors[0] === 'rainbow' ? '#6366f1' : AppState.colors[0], intensity));
                        reactiveGradient.addColorStop(1, 'transparent');
                        this.ctx.fillStyle = reactiveGradient;
                        this.ctx.fillRect(0, 0, this.width, this.height);
                        break;
                    default:
                        this.ctx.fillStyle = '#0f0f1a';
                        this.ctx.fillRect(0, 0, this.width, this.height);
                }
            }

            getColor(index, total) {
                if (AppState.colors[0] === 'rainbow') {
                    const hue = (index / total) * 360;
                    return `hsl(${hue}, 80%, 60%)`;
                }
                
                const [c1, c2] = AppState.colors;
                const ratio = index / total;
                return this.interpolateColor(c1, c2, ratio);
            }

            interpolateColor(color1, color2, ratio) {
                try {
                    const r1 = parseInt(color1.slice(1, 3), 16);
                    const g1 = parseInt(color1.slice(3, 5), 16);
                    const b1 = parseInt(color1.slice(5, 7), 16);
                    const r2 = parseInt(color2.slice(1, 3), 16);
                    const g2 = parseInt(color2.slice(3, 5), 16);
                    const b2 = parseInt(color2.slice(5, 7), 16);
                    
                    const r = Math.round(r1 + (r2 - r1) * ratio);
                    const g = Math.round(g1 + (g2 - g1) * ratio);
                    const b = Math.round(b1 + (b2 - b1) * ratio);
                    
                    return `rgb(${r}, ${g}, ${b})`;
                } catch (e) {
                    return color1;
                }
            }

            hexToRgba(hex, alpha) {
                if (hex.startsWith('hsl')) {
                    return hex.replace(')', `, ${alpha})`).replace('hsl', 'hsla');
                }
                if (hex.startsWith('rgb')) {
                    return hex.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                }
                try {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                } catch (e) {
                    return `rgba(99, 102, 241, ${alpha})`;
                }
            }

            drawBars() {
                if (!this.frequencyData) return;
                
                const barCount = AppState.barCount;
                const barWidth = this.width / barCount;
                const gap = Math.max(1, barWidth * 0.1);
                const sensitivity = AppState.sensitivity / 100;
                const maxHeight = this.height * 0.85;
                
                for (let i = 0; i < barCount; i++) {
                    // Map bar index to frequency data index (use lower frequencies more)
                    const freqIndex = Math.floor(Math.pow(i / barCount, 1.5) * (this.bufferLength / 2));
                    const value = this.frequencyData[freqIndex] || 0;
                    const normalizedValue = (value / 255) * sensitivity;
                    const barHeight = Math.max(2, normalizedValue * maxHeight);
                    
                    const x = i * barWidth;
                    const y = this.height - barHeight;
                    
                    // Create gradient for bar
                    const gradient = this.ctx.createLinearGradient(x, this.height, x, y);
                    const color = this.getColor(i, barCount);
                    gradient.addColorStop(0, color);
                    gradient.addColorStop(1, this.hexToRgba(color, 0.4));
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(x + gap / 2, y, barWidth - gap, barHeight);
                    
                    // Draw reflection
                    const reflectionGradient = this.ctx.createLinearGradient(x, this.height, x, this.height + barHeight * 0.3);
                    reflectionGradient.addColorStop(0, this.hexToRgba(color, 0.2));
                    reflectionGradient.addColorStop(1, 'transparent');
                    this.ctx.fillStyle = reflectionGradient;
                    this.ctx.fillRect(x + gap / 2, this.height, barWidth - gap, barHeight * 0.3);
                }
            }

            drawWave() {
                if (!this.dataArray) return;
                
                const sensitivity = AppState.sensitivity / 100;
                const sliceWidth = this.width / this.bufferLength;
                
                // Draw multiple waves
                for (let wave = 0; wave < 3; wave++) {
                    this.ctx.beginPath();
                    
                    let x = 0;
                    for (let i = 0; i < this.bufferLength; i++) {
                        const v = (this.dataArray[i] / 128.0 - 1) * sensitivity;
                        const y = (v * this.height / 3) + this.height / 2 + wave * 5;
                        
                        if (i === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                        x += sliceWidth;
                    }
                    
                    const color = this.getColor(wave, 3);
                    this.ctx.strokeStyle = this.hexToRgba(color, 0.8 - wave * 0.2);
                    this.ctx.lineWidth = 3 - wave;
                    this.ctx.stroke();
                }
                
                // Fill under the wave
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.height / 2);
                
                let x = 0;
                for (let i = 0; i < this.bufferLength; i++) {
                    const v = (this.dataArray[i] / 128.0 - 1) * sensitivity;
                    const y = (v * this.height / 3) + this.height / 2;
                    this.ctx.lineTo(x, y);
                    x += sliceWidth;
                }
                
                this.ctx.lineTo(this.width, this.height);
                this.ctx.lineTo(0, this.height);
                this.ctx.closePath();
                
                const fillGradient = this.ctx.createLinearGradient(0, this.height / 2, 0, this.height);
                fillGradient.addColorStop(0, this.hexToRgba(AppState.colors[0] === 'rainbow' ? '#6366f1' : AppState.colors[0], 0.3));
                fillGradient.addColorStop(1, 'transparent');
                this.ctx.fillStyle = fillGradient;
                this.ctx.fill();
            }

            drawCircular() {
                if (!this.frequencyData) return;
                
                const centerX = this.width / 2;
                const centerY = this.height / 2;
                const baseRadius = Math.min(this.width, this.height) * 0.2;
                const sensitivity = AppState.sensitivity / 100;
                const bars = 128;
                
                // Draw bars radiating outward
                for (let i = 0; i < bars; i++) {
                    const freqIndex = Math.floor((i / bars) * (this.bufferLength / 2));
                    const value = this.frequencyData[freqIndex] || 0;
                    const barHeight = (value / 255) * baseRadius * sensitivity;
                    
                    const angle = (i / bars) * Math.PI * 2 - Math.PI / 2;
                    const x1 = centerX + Math.cos(angle) * baseRadius;
                    const y1 = centerY + Math.sin(angle) * baseRadius;
                    const x2 = centerX + Math.cos(angle) * (baseRadius + barHeight);
                    const y2 = centerY + Math.sin(angle) * (baseRadius + barHeight);
                    
                    const color = this.getColor(i, bars);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, y1);
                    this.ctx.lineTo(x2, y2);
                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = Math.max(2, (Math.PI * 2 * baseRadius) / bars - 1);
                    this.ctx.lineCap = 'round';
                    this.ctx.stroke();
                }
                
                // Draw inner glow
                const avgFreq = this.frequencyData.reduce((a, b) => a + b, 0) / this.frequencyData.length;
                const glowSize = baseRadius * 0.8 + (avgFreq / 255) * baseRadius * 0.3;
                
                const glowGradient = this.ctx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, glowSize
                );
                const color1 = AppState.colors[0] === 'rainbow' ? '#6366f1' : AppState.colors[0];
                const color2 = AppState.colors[0] === 'rainbow' ? '#ec4899' : AppState.colors[1];
                glowGradient.addColorStop(0, this.hexToRgba(color1, 0.4));
                glowGradient.addColorStop(0.5, this.hexToRgba(color2, 0.2));
                glowGradient.addColorStop(1, 'transparent');
                
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, glowSize, 0, Math.PI * 2);
                this.ctx.fillStyle = glowGradient;
                this.ctx.fill();
                
                // Draw center circle
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, baseRadius * 0.3, 0, Math.PI * 2);
                this.ctx.fillStyle = this.hexToRgba(color1, 0.8);
                this.ctx.fill();
            }

            drawParticles() {
                if (!this.frequencyData) return;
                
                const avgFreq = this.frequencyData.reduce((a, b) => a + b, 0) / this.frequencyData.length;
                const sensitivity = AppState.sensitivity / 100;
                const bassFreq = this.frequencyData.slice(0, 10).reduce((a, b) => a + b, 0) / 10;
                
                // Add particles based on bass frequency
                if (bassFreq > 80) {
                    const particleCount = Math.floor((bassFreq / 255) * 5 * sensitivity);
                    for (let i = 0; i < particleCount; i++) {
                        this.particles.push({
                            x: Math.random() * this.width,
                            y: this.height + 10,
                            vx: (Math.random() - 0.5) * 6,
                            vy: -(Math.random() * 8 + 4) * sensitivity,
                            size: Math.random() * 6 + 2,
                            color: this.getColor(Math.floor(Math.random() * 10), 10),
                            life: 1,
                            decay: 0.008 + Math.random() * 0.01
                        });
                    }
                }
                
                // Update and draw particles
                this.particles = this.particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.15; // gravity
                    p.life -= p.decay;
                    
                    if (p.life <= 0 || p.y > this.height + 50) return false;
                    
                    // Main particle
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                    this.ctx.fillStyle = this.hexToRgba(p.color, p.life);
                    this.ctx.fill();
                    
                    // Glow
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size * p.life * 2.5, 0, Math.PI * 2);
                    this.ctx.fillStyle = this.hexToRgba(p.color, p.life * 0.2);
                    this.ctx.fill();
                    
                    return true;
                });
                
                // Limit particles
                if (this.particles.length > 300) {
                    this.particles = this.particles.slice(-300);
                }
                
                // Draw frequency bars at bottom
                const barCount = 48;
                const barWidth = this.width / barCount;
                
                for (let i = 0; i < barCount; i++) {
                    const freqIndex = Math.floor((i / barCount) * (this.bufferLength / 2));
                    const value = this.frequencyData[freqIndex] || 0;
                    const barHeight = (value / 255) * 80 * sensitivity;
                    
                    const color = this.getColor(i, barCount);
                    this.ctx.fillStyle = this.hexToRgba(color, 0.4);
                    this.ctx.fillRect(i * barWidth, this.height - barHeight, barWidth - 2, barHeight);
                }
            }

            drawSpectrum() {
                if (!this.frequencyData) return;
                
                const sensitivity = AppState.sensitivity / 100;
                const barCount = 96;
                const barWidth = this.width / barCount;
                const maxHeight = this.height * 0.45;
                
                for (let i = 0; i < barCount; i++) {
                    const freqIndex = Math.floor(Math.pow(i / barCount, 1.3) * (this.bufferLength / 2));
                    const value = this.frequencyData[freqIndex] || 0;
                    const barHeight = (value / 255) * maxHeight * sensitivity;
                    
                    const color = this.getColor(i, barCount);
                    const x = i * barWidth;
                    
                    // Top half (going up from center)
                    const topGradient = this.ctx.createLinearGradient(x, this.height / 2, x, this.height / 2 - barHeight);
                    topGradient.addColorStop(0, color);
                    topGradient.addColorStop(1, this.hexToRgba(color, 0.2));
                    
                    this.ctx.fillStyle = topGradient;
                    this.ctx.fillRect(x + 1, this.height / 2 - barHeight, barWidth - 2, barHeight);
                    
                    // Bottom half (going down from center) - mirror
                    const bottomGradient = this.ctx.createLinearGradient(x, this.height / 2, x, this.height / 2 + barHeight);
                    bottomGradient.addColorStop(0, color);
                    bottomGradient.addColorStop(1, this.hexToRgba(color, 0.2));
                    
                    this.ctx.fillStyle = bottomGradient;
                    this.ctx.fillRect(x + 1, this.height / 2, barWidth - 2, barHeight);
                }
                
                // Center line glow
                const avgFreq = this.frequencyData.reduce((a, b) => a + b, 0) / this.frequencyData.length;
                const glowIntensity = avgFreq / 255;
                
                const lineGradient = this.ctx.createLinearGradient(0, this.height / 2 - 15, 0, this.height / 2 + 15);
                lineGradient.addColorStop(0, 'transparent');
                lineGradient.addColorStop(0.5, this.hexToRgba(AppState.colors[0] === 'rainbow' ? '#ffffff' : AppState.colors[0], glowIntensity * 0.6));
                lineGradient.addColorStop(1, 'transparent');
                
                this.ctx.fillStyle = lineGradient;
                this.ctx.fillRect(0, this.height / 2 - 15, this.width, 30);
            }

            stop() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }
        }

        // ==================== UI Controller ====================
        class UIController {
            constructor() {
                this.db = new AudioDatabase();
                this.visualizer = new AudioVisualizer();
                this.elements = this.cacheElements();
                this.lastVolume = 80;
                this.bindEvents();
            }

            cacheElements() {
                return {
                    uploadBtn: document.getElementById('uploadBtn'),
                    uploadModal: document.getElementById('uploadModal'),
                    closeModal: document.getElementById('closeModal'),
                    uploadArea: document.getElementById('uploadArea'),
                    fileInput: document.getElementById('fileInput'),
                    libraryList: document.getElementById('libraryList'),
                    emptyLibrary: document.getElementById('emptyLibrary'),
                    playBtn: document.getElementById('playBtn'),
                    playIcon: document.getElementById('playIcon'),
                    prevBtn: document.getElementById('prevBtn'),
                    nextBtn: document.getElementById('nextBtn'),
                    progressBar: document.getElementById('progressBar'),
                    progressFill: document.getElementById('progressFill'),
                    currentTime: document.getElementById('currentTime'),
                    duration: document.getElementById('duration'),
                    volumeSlider: document.getElementById('volumeSlider'),
                    volumeBtn: document.getElementById('volumeBtn'),
                    shuffleBtn: document.getElementById('shuffleBtn'),
                    repeatBtn: document.getElementById('repeatBtn'),
                    trackName: document.getElementById('trackName'),
                    vizMode: document.getElementById('vizMode'),
                    settingsBtn: document.getElementById('settingsBtn'),
                    settingsPanel: document.getElementById('settingsPanel'),
                    closeSettings: document.getElementById('closeSettings'),
                    sidebar: document.getElementById('sidebar'),
                    sidebarToggle: document.getElementById('sidebarToggle'),
                    closeSidebar: document.getElementById('closeSidebar'),
                    fullscreenBtn: document.getElementById('fullscreenBtn'),
                    vizModeOptions: document.getElementById('vizModeOptions'),
                    colorOptions: document.getElementById('colorOptions'),
                    sensitivitySlider: document.getElementById('sensitivitySlider'),
                    sensitivityValue: document.getElementById('sensitivityValue'),
                    smoothingSlider: document.getElementById('smoothingSlider'),
                    smoothingValue: document.getElementById('smoothingValue'),
                    barCountSlider: document.getElementById('barCountSlider'),
                    barCountValue: document.getElementById('barCountValue'),
                    bgOptions: document.getElementById('bgOptions'),
                    resetSettings: document.getElementById('resetSettings'),
                    storageFill: document.getElementById('storageFill'),
                    storageUsed: document.getElementById('storageUsed'),
                    toastContainer: document.getElementById('toastContainer')
                };
            }

            async init() {
                await this.db.init();
                AppState.load();
                await this.loadLibrary();
                this.applyState();
                this.startProgressUpdate();
            }

            bindEvents() {
                // Upload
                this.elements.uploadBtn.onclick = () => this.openModal();
                this.elements.closeModal.onclick = () => this.closeModal();
                this.elements.uploadModal.onclick = (e) => {
                    if (e.target === this.elements.uploadModal) this.closeModal();
                };
                
                this.elements.uploadArea.onclick = () => this.elements.fileInput.click();
                this.elements.fileInput.onchange = (e) => this.handleFiles(e.target.files);
                
                // Drag and drop
                this.elements.uploadArea.ondragover = (e) => {
                    e.preventDefault();
                    this.elements.uploadArea.classList.add('dragover');
                };
                this.elements.uploadArea.ondragleave = () => {
                    this.elements.uploadArea.classList.remove('dragover');
                };
                this.elements.uploadArea.ondrop = (e) => {
                    e.preventDefault();
                    this.elements.uploadArea.classList.remove('dragover');
                    this.handleFiles(e.dataTransfer.files);
                };

                // Player
                this.elements.playBtn.onclick = () => this.togglePlay();
                this.elements.prevBtn.onclick = () => this.prevTrack();
                this.elements.nextBtn.onclick = () => this.nextTrack();
                this.elements.progressBar.onclick = (e) => this.seek(e);
                this.elements.volumeSlider.oninput = (e) => this.setVolume(parseInt(e.target.value));
                this.elements.volumeBtn.onclick = () => this.toggleMute();
                this.elements.shuffleBtn.onclick = () => this.toggleShuffle();
                this.elements.repeatBtn.onclick = () => this.toggleRepeat();

                // Audio events
                this.visualizer.audio.onended = () => this.onTrackEnd();
                this.visualizer.audio.onplay = () => {
                    AppState.isPlaying = true;
                    this.updatePlayButton(true);
                };
                this.visualizer.audio.onpause = () => {
                    AppState.isPlaying = false;
                    this.updatePlayButton(false);
                };

                // Settings
                this.elements.settingsBtn.onclick = () => this.toggleSettings();
                this.elements.closeSettings.onclick = () => this.toggleSettings(false);

                // Sidebar
                this.elements.sidebarToggle.onclick = () => this.toggleSidebar();
                this.elements.closeSidebar.onclick = () => this.toggleSidebar(false);

                // Fullscreen
                this.elements.fullscreenBtn.onclick = () => this.toggleFullscreen();

                // Viz mode
                this.elements.vizModeOptions.onclick = (e) => {
                    if (e.target.classList.contains('setting-option')) {
                        this.setVizMode(e.target.dataset.mode);
                    }
                };

                // Colors
                this.elements.colorOptions.onclick = (e) => {
                    const option = e.target.closest('.color-option');
                    if (option) {
                        this.setColors(JSON.parse(option.dataset.colors));
                    }
                };

                // Sliders
                this.elements.sensitivitySlider.oninput = (e) => {
                    AppState.sensitivity = parseInt(e.target.value);
                    this.elements.sensitivityValue.textContent = `${e.target.value}%`;
                    AppState.save();
                };

                this.elements.smoothingSlider.oninput = (e) => {
                    AppState.smoothing = parseInt(e.target.value);
                    this.elements.smoothingValue.textContent = `${e.target.value}%`;
                    AppState.save();
                };

                this.elements.barCountSlider.oninput = (e) => {
                    AppState.barCount = parseInt(e.target.value);
                    this.elements.barCountValue.textContent = e.target.value;
                    AppState.save();
                };

                // Background
                this.elements.bgOptions.onclick = (e) => {
                    if (e.target.classList.contains('setting-option')) {
                        this.setBackground(e.target.dataset.bg);
                    }
                };

                this.elements.resetSettings.onclick = () => this.resetSettings();

                // Keyboard
                document.onkeydown = (e) => this.handleKeyboard(e);
            }

            applyState() {
                // Volume
                this.elements.volumeSlider.value = AppState.volume;
                this.visualizer.setVolume(AppState.volume);
                
                // Shuffle & Repeat
                this.elements.shuffleBtn.classList.toggle('active', AppState.shuffle);
                this.elements.repeatBtn.classList.toggle('active', AppState.repeat);
                
                // Viz mode
                this.setVizMode(AppState.vizMode, false);
                
                // Colors
                this.setColors(AppState.colors, false);
                
                // Background
                this.setBackground(AppState.background, false);
                
                // Sliders
                this.elements.sensitivitySlider.value = AppState.sensitivity;
                this.elements.sensitivityValue.textContent = `${AppState.sensitivity}%`;
                
                this.elements.smoothingSlider.value = AppState.smoothing;
                this.elements.smoothingValue.textContent = `${AppState.smoothing}%`;
                
                this.elements.barCountSlider.value = AppState.barCount;
                this.elements.barCountValue.textContent = AppState.barCount;
                
                // Play button state
                this.updatePlayButton(AppState.isPlaying);
            }

            async loadLibrary() {
                const files = await this.db.getAllFiles();
                AppState.playlist = files.sort((a, b) => b.addedAt - a.addedAt);
                this.renderLibrary();
                this.updateStorageInfo();
                
                // Restore current track
                if (AppState.playlist.length > 0 && AppState.currentIndex >= 0) {
                    const index = Math.min(AppState.currentIndex, AppState.playlist.length - 1);
                    await this.loadTrack(index, false);
                }
            }

            renderLibrary() {
                const container = this.elements.libraryList;
                
                // Remove existing items
                const existingItems = container.querySelectorAll('.library-item');
                existingItems.forEach(item => item.remove());
                
                if (AppState.playlist.length === 0) {
                    this.elements.emptyLibrary.style.display = 'flex';
                    return;
                }
                
                this.elements.emptyLibrary.style.display = 'none';
                
                AppState.playlist.forEach((file, index) => {
                    const item = document.createElement('div');
                    item.className = `library-item${index === AppState.currentIndex ? ' active' : ''}`;
                    item.innerHTML = `
                        <div class="library-item-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20">
                                <path d="M9 18V5l12-2v13"/>
                                <circle cx="6" cy="18" r="3"/>
                                <circle cx="18" cy="16" r="3"/>
                            </svg>
                        </div>
                        <div class="library-item-info">
                            <div class="library-item-name">${this.formatFileName(file.name)}</div>
                            <div class="library-item-size">${this.formatSize(file.size)}</div>
                        </div>
                        <div class="library-item-actions">
                            <button class="btn btn-secondary btn-icon" data-action="download" title="Download">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                    <polyline points="7 10 12 15 17 10"/>
                                    <line x1="12" y1="15" x2="12" y2="3"/>
                                </svg>
                            </button>
                            <button class="btn btn-danger btn-icon" data-action="delete" title="Delete">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                                    <polyline points="3 6 5 6 21 6"/>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                                </svg>
                            </button>
                        </div>
                    `;
                    
                    item.onclick = (e) => {
                        const action = e.target.closest('[data-action]')?.dataset.action;
                        if (action === 'download') {
                            e.stopPropagation();
                            this.downloadFile(file);
                        } else if (action === 'delete') {
                            e.stopPropagation();
                            this.deleteFile(file.id, index);
                        } else {
                            this.loadTrack(index);
                        }
                    };
                    
                    container.appendChild(item);
                });
            }

            async handleFiles(files) {
                for (const file of files) {
                    if (!file.type.startsWith('audio/')) {
                        this.showToast('Only audio files are supported', 'error');
                        continue;
                    }
                    
                    const currentSize = await this.db.getTotalSize();
                    if (currentSize + file.size > this.db.maxStorage) {
                        this.showToast('Storage limit reached. Delete some files first.', 'error');
                        break;
                    }
                    
                    try {
                        await this.db.saveFile(file);
                        this.showToast(`Added: ${this.formatFileName(file.name)}`, 'success');
                    } catch (error) {
                        this.showToast(`Failed to add: ${file.name}`, 'error');
                        console.error(error);
                    }
                }
                
                await this.loadLibrary();
                this.closeModal();
            }

            async loadTrack(index, autoPlay = true) {
                if (index < 0 || index >= AppState.playlist.length) return;
                
                AppState.currentIndex = index;
                const file = AppState.playlist[index];
                
                try {
                    await this.visualizer.loadTrack(file);
                    this.elements.trackName.textContent = this.formatFileName(file.name);
                    this.updateActiveLibraryItem();
                    
                    if (autoPlay) {
                        this.visualizer.play();
                    }
                    
                    AppState.save();
                } catch (error) {
                    console.error('Failed to load track:', error);
                    this.showToast('Failed to load track', 'error');
                }
            }

            togglePlay() {
                if (AppState.currentIndex < 0 && AppState.playlist.length > 0) {
                    this.loadTrack(0);
                    return;
                }
                
                if (AppState.currentIndex < 0) {
                    this.showToast('Upload a track first', 'error');
                    return;
                }
                
                if (AppState.isPlaying) {
                    this.visualizer.pause();
                } else {
                    this.visualizer.play();
                }
            }

            updatePlayButton(isPlaying) {
                const icon = this.elements.playIcon;
                if (isPlaying) {
                    icon.innerHTML = '<rect x="6" y="4" width="4" height="16" fill="white"/><rect x="14" y="4" width="4" height="16" fill="white"/>';
                } else {
                    icon.innerHTML = '<polygon points="5 3 19 12 5 21 5 3" fill="white"/>';
                }
                document.body.classList.toggle('playing', isPlaying);
            }

            prevTrack() {
                if (AppState.playlist.length === 0) return;
                
                let newIndex;
                if (AppState.shuffle) {
                    newIndex = Math.floor(Math.random() * AppState.playlist.length);
                } else {
                    newIndex = AppState.currentIndex - 1;
                    if (newIndex < 0) newIndex = AppState.playlist.length - 1;
                }
                
                this.loadTrack(newIndex);
            }

            nextTrack() {
                if (AppState.playlist.length === 0) return;
                
                let newIndex;
                if (AppState.shuffle) {
                    newIndex = Math.floor(Math.random() * AppState.playlist.length);
                } else {
                    newIndex = AppState.currentIndex + 1;
                    if (newIndex >= AppState.playlist.length) newIndex = 0;
                }
                
                this.loadTrack(newIndex);
            }

            onTrackEnd() {
                if (AppState.repeat) {
                    this.visualizer.audio.currentTime = 0;
                    this.visualizer.play();
                } else {
                    this.nextTrack();
                }
            }

            seek(e) {
                const rect = this.elements.progressBar.getBoundingClientRect();
                const percent = ((e.clientX - rect.left) / rect.width) * 100;
                this.visualizer.seek(Math.max(0, Math.min(100, percent)));
            }

            setVolume(value) {
                AppState.volume = value;
                this.visualizer.setVolume(value);
                AppState.save();
            }

            toggleMute() {
                if (AppState.volume > 0) {
                    this.lastVolume = AppState.volume;
                    this.setVolume(0);
                    this.elements.volumeSlider.value = 0;
                } else {
                    this.setVolume(this.lastVolume || 80);
                    this.elements.volumeSlider.value = this.lastVolume || 80;
                }
            }

            toggleShuffle() {
                AppState.shuffle = !AppState.shuffle;
                this.elements.shuffleBtn.classList.toggle('active', AppState.shuffle);
                AppState.save();
                this.showToast(`Shuffle ${AppState.shuffle ? 'on' : 'off'}`);
            }

            toggleRepeat() {
                AppState.repeat = !AppState.repeat;
                this.elements.repeatBtn.classList.toggle('active', AppState.repeat);
                AppState.save();
                this.showToast(`Repeat ${AppState.repeat ? 'on' : 'off'}`);
            }

            startProgressUpdate() {
                setInterval(() => {
                    this.elements.progressFill.style.width = `${this.visualizer.getProgress()}%`;
                    this.elements.currentTime.textContent = this.visualizer.getCurrentTime();
                    this.elements.duration.textContent = this.visualizer.getDuration();
                }, 100);
            }

            updateActiveLibraryItem() {
                const items = this.elements.libraryList.querySelectorAll('.library-item');
                items.forEach((item, i) => {
                    item.classList.toggle('active', i === AppState.currentIndex);
                });
            }

            setVizMode(mode, save = true) {
                AppState.vizMode = mode;
                
                this.elements.vizModeOptions.querySelectorAll('.setting-option').forEach(opt => {
                    opt.classList.toggle('active', opt.dataset.mode === mode);
                });
                
                const modeNames = {
                    bars: 'Bars Visualization',
                    wave: 'Wave Visualization',
                    circular: 'Circular Visualization',
                    particles: 'Particles Visualization',
                    spectrum: 'Spectrum Visualization'
                };
                this.elements.vizMode.textContent = modeNames[mode] || 'Visualization';
                
                if (save) AppState.save();
            }

            setColors(colors, save = true) {
                AppState.colors = colors;
                
                this.elements.colorOptions.querySelectorAll('.color-option').forEach(opt => {
                    const optColors = JSON.parse(opt.dataset.colors);
                    const match = JSON.stringify(optColors) === JSON.stringify(colors);
                    opt.classList.toggle('active', match);
                });
                
                if (save) AppState.save();
            }

            setBackground(bg, save = true) {
                AppState.background = bg;
                
                this.elements.bgOptions.querySelectorAll('.setting-option').forEach(opt => {
                    opt.classList.toggle('active', opt.dataset.bg === bg);
                });
                
                if (save) AppState.save();
            }

            resetSettings() {
                AppState.vizMode = 'bars';
                AppState.colors = ['#6366f1', '#ec4899'];
                AppState.sensitivity = 100;
                AppState.smoothing = 80;
                AppState.barCount = 64;
                AppState.background = 'dark';
                
                this.applyState();
                AppState.save();
                this.showToast('Settings reset');
            }

            toggleSettings(open) {
                const panel = this.elements.settingsPanel;
                if (open === undefined) {
                    panel.classList.toggle('open');
                } else {
                    panel.classList.toggle('open', open);
                }
            }

            toggleSidebar(open) {
                const sidebar = this.elements.sidebar;
                if (open === undefined) {
                    sidebar.classList.toggle('open');
                } else {
                    sidebar.classList.toggle('open', open);
                }
            }

            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            }

            async deleteFile(id, index) {
                await this.db.deleteFile(id);
                
                if (index === AppState.currentIndex) {
                    this.visualizer.pause();
                    this.visualizer.audio.src = '';
                    AppState.currentIndex = -1;
                    AppState.isPlaying = false;
                    this.elements.trackName.textContent = 'No Track Selected';
                    this.updatePlayButton(false);
                } else if (index < AppState.currentIndex) {
                    AppState.currentIndex--;
                }
                
                AppState.save();
                await this.loadLibrary();
                this.showToast('File deleted', 'success');
            }

            downloadFile(file) {
                const blob = new Blob([file.data], { type: file.type });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = file.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                this.showToast('Download started', 'success');
            }

            async updateStorageInfo() {
                const used = await this.db.getTotalSize();
                const percent = (used / this.db.maxStorage) * 100;
                
                this.elements.storageFill.style.width = `${percent}%`;
                this.elements.storageUsed.textContent = this.formatSize(used);
            }

            openModal() {
                this.elements.uploadModal.classList.add('open');
            }

            closeModal() {
                this.elements.uploadModal.classList.remove('open');
                this.elements.fileInput.value = '';
            }

            formatFileName(name) {
                return name.replace(/\.[^/.]+$/, '').substring(0, 50);
            }

            formatSize(bytes) {
                if (bytes < 1024) return bytes + ' B';
                if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
            }

            showToast(message, type = 'success') {
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20">
                        ${type === 'success' 
                            ? '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/>'
                            : '<circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/>'
                        }
                    </svg>
                    <span>${message}</span>
                `;
                
                this.elements.toastContainer.appendChild(toast);
                
                setTimeout(() => {
                    toast.style.opacity = '0';
                    toast.style.transition = 'opacity 0.3s';
                    setTimeout(() => toast.remove(), 300);
                }, 3000);
            }

            handleKeyboard(e) {
                // Don't trigger if typing in input
                if (e.target.tagName === 'INPUT') return;
                
                switch (e.code) {
                    case 'Space':
                        e.preventDefault();
                        this.togglePlay();
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        this.visualizer.audio.currentTime = Math.max(0, this.visualizer.audio.currentTime - 5);
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        this.visualizer.audio.currentTime = Math.min(
                            this.visualizer.audio.duration || 0,
                            this.visualizer.audio.currentTime + 5
                        );
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        const newVolUp = Math.min(100, AppState.volume + 5);
                        this.setVolume(newVolUp);
                        this.elements.volumeSlider.value = newVolUp;
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        const newVolDown = Math.max(0, AppState.volume - 5);
                        this.setVolume(newVolDown);
                        this.elements.volumeSlider.value = newVolDown;
                        break;
                    case 'KeyM':
                        this.toggleMute();
                        break;
                    case 'KeyF':
                        this.toggleFullscreen();
                        break;
                }
            }
        }

        // ==================== Initialize ====================
        const app = new UIController();
        app.init().catch(console.error);
    </script>
</body>
</html>
